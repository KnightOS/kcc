<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="GENERATOR" content="Mozilla/4.51 [en] (X11; I; Linux 2.2.5-15 i686) [Netscape]">
</head>
<body>

<h1>
<u>CDB File format Description</u></h1>
The .cdb file created when the --debug option is used contains&nbsp; the
following types of records. The records are stored one per&nbsp; line,
and the first character determines the record type.
<br>&nbsp;
<h4>
<u>Type Description Generated by</u></h4>

<ul>
<li>
'S'&nbsp;&nbsp;&nbsp; Symbol Record Compiler</li>

<li>
'T'&nbsp;&nbsp;&nbsp; Structure description record Compiler</li>

<li>
'L'&nbsp;&nbsp;&nbsp; Linker record assembler/linker</li>

<li>
'F'&nbsp;&nbsp;&nbsp; Function record Compiler</li>

<li>
'M'&nbsp;&nbsp; Module record Compiler</li>
</ul>

<h4>
<u>Details of 'S'-Type (Symbol Record)</u></h4>
A symbol record is generated for each named symbol in the source file (local,
global &amp; parameter). The format of the symbol record is as follows.
<p><i>S:{G|F&lt;filename>|L&lt;functionName>}$&lt;name>$&lt;level>$&lt;block>
(&lt;type info>),&lt;Address Space>,&lt;on Stack?>,&lt;stack offset></i>
<p>Following the record type is the scope information for the symbol.&nbsp;
'G' indicates Global . F&lt;filename> indicates the symbol is active for
a given file only (e.g. global variables declared as 'static') L&lt;functionName>
indicates that the symbol is local to the function with the given name.
The follows the name of the variable (this is&nbsp; the unmangled/user
given name of the variable). The level &amp; block are used to further
scope local variables since C allows the&nbsp; definitions like ...
<p>foo()
<br>{
<br>&nbsp;&nbsp;&nbsp; int c; /* block #1 , level #1 */
<br>&nbsp;&nbsp;&nbsp; {
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int c; /* block #2, level
#2 */
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...
<br>&nbsp;&nbsp;&nbsp; }
<p>&nbsp;&nbsp;&nbsp; {
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int c; /* block #3 , level
#2 */
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...
<br>&nbsp;&nbsp;&nbsp; }
<br>}
<p>The type info is a chain of type (since C allows declarations of arbitrary
complexity. The type info has the following format .
<p><i>({size}&lt;type info chain>)</i>
<p><i>size </i>- size in bytes of the symbol.
<p><i>&lt;type info chain></i> - should be parsed into a linked list of
type, the elements of the list are described below.
<br>&nbsp;
<br>&nbsp;
<center><table BORDER=3 CELLSPACING=3 WIDTH="500" BGCOLOR="#CCCCCC" NOSAVE >
<tr NOSAVE>
<td NOSAVE><b>Type Code</b></td>

<td NOSAVE><b>Description</b></td>
</tr>

<tr NOSAVE>
<td NOSAVE>DA&lt;n></td>

<td NOSAVE>Array of n elements</td>
</tr>

<tr>
<td>DF</td>

<td>Function</td>
</tr>

<tr>
<td>DG</td>

<td>Generic pointer</td>
</tr>

<tr>
<td>DC</td>

<td>Code pointer</td>
</tr>

<tr>
<td>DX</td>

<td>Xternal Ram pointer</td>
</tr>

<tr>
<td>DD</td>

<td>Internal ram pointer</td>
</tr>

<tr>
<td>DP</td>

<td>Paged pointer</td>
</tr>

<tr NOSAVE>
<td>DI</td>

<td NOSAVE>Upper 128 byte pointer</td>
</tr>

<tr>
<td>SL</td>

<td>long</td>
</tr>

<tr>
<td>SI</td>

<td>int</td>
</tr>

<tr>
<td>SC</td>

<td>char</td>
</tr>

<tr>
<td>SS</td>

<td>short</td>
</tr>

<tr>
<td>SV</td>

<td>void</td>
</tr>

<tr>
<td>SF</td>

<td>float</td>
</tr>

<tr>
<td>ST&lt;name></td>

<td>structure of name &lt;name></td>
</tr>

<tr>
<td>SX&nbsp;</td>

<td>sbit</td>
</tr>

<tr>
<td>SB&lt;n></td>

<td>bit field of &lt;n> bits.</td>
</tr>
</table></center>

<p>Address Space
<br>Code Description
<br>---- -----------
<br>&nbsp;
<center><table BORDER WIDTH="500" NOSAVE >
<tr NOSAVE>
<td NOSAVE><b>Address Space</b>
<br><b>Code&nbsp;</b></td>

<td><b>Description of address space</b></td>
</tr>

<tr>
<td>A</td>

<td>External stack</td>
</tr>

<tr>
<td>B</td>

<td>Internal stack</td>
</tr>

<tr>
<td>C</td>

<td>Code</td>
</tr>

<tr>
<td>D</td>

<td>Code/static segment</td>
</tr>

<tr>
<td>E</td>

<td>Internal ram (lower 128) bytes</td>
</tr>

<tr>
<td>F</td>

<td>External ram</td>
</tr>

<tr>
<td>G</td>

<td>Internal ram</td>
</tr>

<tr>
<td>H</td>

<td>Bit addressable</td>
</tr>

<tr>
<td>I</td>

<td>SFR space</td>
</tr>

<tr>
<td>J</td>

<td>SBIT space</td>
</tr>
</table></center>

<br>&nbsp;
<p>Sign Information
<br>Code Description
<br>---- -----------
<br>S Signed
<br>U Unsigned
<p>Examples
<br>--------
<br>This is best illustrated with a few examples.
<p>Declaration.
<p>idata char BCD_Cell[5];
<p>Generates the following debug info.
<p>S:G$BCD_cell$0$0({5}DA5,SC:S),G,0,0
<br>&nbsp;
<p>The following function declaration along with local variables and parameters.
<p>void uitoa(unsigned int value, char* string, int radix)
<br>{
<br>char buffer[NUMBER_OF_DIGITS];
<p>..
<br>}
<p>Will generate the following debug information.
<p>/* function "uitoa" */
<br>F:G$uitoa$0$0({2}DF,SV:S),C,0,0
<p>/* parameter "value" */
<br>S:Luitoa$value$1$1({2}SI:S),E,0,0
<p>/* parameter "string" */
<br>S:Luitoa$string$1$1({3}DG,SC:S),E,0,0
<p>/* parameter "radix" */
<br>S:Luitoa$radix$1$1({2}SI:S),E,0,0
<p>/* local variable "buffer" */
<br>S:Luitoa$buffer$1$1({16}DA16,SC:S),E,0,0
<br>&nbsp;
<p>Details of 'T'-Type (Structure Record)
<br>--------------------------------------
<br>Structure definitions ALWAYS have file scope. Currently structure definitions
<br>within functions or blocks are not handled in the debug information.
Structure
<br>and unions are represented using the same debug format. The format
of the
<br>Structure record is as follows .
<p>T:F&lt;filename>$tag[({offset}&lt;Symbol Record 'S' type for 1st field>)
<br>({offset}&lt;Symbol Record 'S' type for 2nd field>)
<br>...
<br>...
<br>]
<p>Example 1.
<br>----------
<p>Definition
<p>struct some_struct {
<br>int a;
<br>char b;
<br>long c;
<br>};
<p>Generates the following 'T' - type record.
<p>T:Fprob38$some_struct[
<br>/* field 'a' offset = 0 */
<br>({0}S:S$a$1$0({2}SI:S),Z,0,0)
<br>/* field 'b' offset = 2 */
<br>({2}S:S$b$1$0({1}SC:S),Z,0,0)
<br>/* field 'c' offset = 3 */
<br>({3}S:S$c$1$0({4}SL:S),Z,0,0)]
<p>The 'S' - type (symbol rescord for each of the fields is embedded inside
<br>the structure definition record.
<p>Example 2.
<br>----------
<p>Structure declarations with embeded structures.
<p>union bil {
<br>struct {
<br>volatile unsigned char b0,
<br>b1,
<br>b2,
<br>b3 ;
<br>} b;
<br>struct {
<br>volatile unsigned int lo,hi ;
<br>} i;
<br>unsigned volatile long l;
<br>struct {
<br>volatile unsigned char b0;
<br>unsigned int i12;
<br>unsigned char b3;}
<br>bi;
<br>} ;
<br>&nbsp;
<p>Generates the following debug information. NOTE: the embedded anonymous
<br>structures generates separate T - type records.
<p>T:Fprob38$bil[
<br>/* field 'b' is of type Structure __00020000 , offset = 0 */
<br>({0}S:S$b$1$0({4}ST__00020000:S),Z,0,0)
<p>/* field 'i' is of type structre __00020001 , offset = 0 (union) */
<br>({0}S:S$i$1$0({4}ST__00020001:S),Z,0,0)
<p>/* field 'l' is of type unsigned long */
<br>({0}S:S$l$1$0({4}SL:U),Z,0,0)
<p>/* field 'bi' is of type structure __00020002 offset = 0 */
<br>({0}S:S$bi$1$0({4}ST__00020002:S),Z,0,0)]
<p>/* compiler generates these 'T'-type records for the
<br>anonymous structures */
<p>/* T record for structure __00020000 (field 'b' in the above structure)
*/
<p>T:Fprob38$__00020000[
<br>/* field 'b0' type unsigned char , offset = 0 */
<br>({0}S:S$b0$2$0({1}SC:U),Z,0,0)
<p>/* field 'b1' type unsigned char , offset = 1 */
<br>({1}S:S$b1$2$0({1}SC:U),Z,0,0)
<p>/* field 'b2' type unsigned char, offset = 2 */
<br>({2}S:S$b2$2$0({1}SC:U),Z,0,0)
<p>/* field 'b3' type unsigned char , offset = 3 */
<br>({3}S:S$b3$2$0({1}SC:U),Z,0,0)]
<p>/* T record for structure __00020001 (field 'i' in union 'bil' ) */
<p>T:Fprob38$__00020001[
<br>/* field 'lo' type unsigned int offset 0 */
<br>({0}S:S$lo$2$0({2}SI:U),Z,0,0)
<p>/* field 'hi' type unsigned int offset 2 */
<br>({2}S:S$hi$2$0({2}SI:U),Z,0,0)]
<p>/* T record for structure __00020002 (field 'bi' in union 'bil' )*/
<p>T:Fprob38$__00020002[
<br>/* field 'b0' type unsigned char , offset 0 */
<br>({0}S:S$b0$2$0({1}SC:U),Z,0,0)
<p>/* field 'i1' type unsigned int , offset 1 */
<br>({1}S:S$i12$2$0({2}SI:U),Z,0,0)
<p>/* field 'b3' type unsigned char offset 3 */
<br>({3}S:S$b3$2$0({1}SC:U),Z,0,0)]
<p>Details of 'F'-Type (FUNCTION Record)
<br>--------------------------------------
<br>A Function record is created for each function defined in the C Source
<br>file. The format of a function record is identical to that of the Symbol
<br>record. The function record contains information about the return value
<br>of a function, in addition it contains information about the register
bank
<br>the function uses and if the function is an interrupt service routine
the
<br>interrupt number of the function.
<p>Example 1.
<br>----------
</body>
</html>
