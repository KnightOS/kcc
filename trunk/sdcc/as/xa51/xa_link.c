/* WORK IN PROGRESS: do not watch this if you don't have the legal
   age in your country to watch this.
*/

/* This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.

 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

/* This is a cheap hack. The xa51 has a couple of ways to scramble
   relocation info into it's opcode that the standard linker can't
   handle. 

   The relocatable format looks like the known one, BUT ISN'T.

   The only things that are handled now are:

   "SDCCXA rel, version %f" must be the first line, sort of MAGIC word
   "H %d areas %d global symbols" defines the # of areas and globals
   "S <symbol> [Ref0000 | DefXXXX]" Def's are supposed to be defined in
     their own area/segment
   "A <seg> size %d flags %d" switch to another segment. this can happen
     multiple times and should be equal. flags is ignored for now
   "T xx xx bb bb ..." where xx xx is the address within the current segment
     and bb are the bytes
   "R xx <how> <symbol>" the relocation info. xx is the offset within the
     previous "T .." line. <how> could be something like REL_FF, REL_FFFF, 
     ABS_F0FF. symbol is the (previous) defined symbol it refers to

   So, this is not a standalone linker. It will only link files generated
   by xa_asm, which will only process files generated by the xa51 sdcc
   port.
*/

#include <stdio.h>
#include <stdlib.h>
#include <limits.h>
#include <string.h>

#include "xa_version.h"

enum {
  CSEG=1,
  DSEG,
  XSEG,
  BSEG,
  XINIT,
  XISEG,
  GSINIT,
  GSFINAL,
  HOME,
  MAX_SEGMENTS
};

struct SEGMENT {
  short id;
  char *name;
  int start;
  int current;
} segments[MAX_SEGMENTS]={
  {0,       "????",    0, 0},
  {CSEG,    "CSEG",    0, 0},
  {DSEG,    "DSEG",    0, 0},
  {XSEG,    "XSEG",    0, 0},
  {BSEG,    "BSEG",    0, 0},
  {XINIT,   "XINIT",   0, 0},
  {XISEG,   "XISEG",   0, 0},
  {GSINIT,  "GSINIT",  0, 0},
  {GSFINAL, "GSFINAL", 0, 0},
  {HOME,    "HOME",    0, 0},
};

char *libPaths[128];
int nlibPaths=0;
char *libFiles[128];
int nlibFiles=0;

static char outFileName[PATH_MAX];

int currentArea=0;

int getAreaID(char *area) {
  int i;
  for (i=1; i<MAX_SEGMENTS; i++) {
    if (strcmp(segments[i].name, area)==0) {
      return segments[i].id;
    }
  }
  return 0;
}

void addToRefs(char *ref) {
  fprintf (stderr, "Ref: %s\n", ref);
}

void addToDefs(char *def, int address) {
  fprintf (stderr, "Def: %s 0x%04x\n", def, address);
}

void syntaxError (char *err) {
  fprintf (stderr, "error while parsing '%s'\n", err);
  exit(1);
}

void baseName(char *name, char*base) {
  int i, first, last;

  // find the last path seperator in name
  for (first=strlen(name)-1; 
       (name[first]!='/' && name[first]!='\\') && first;
       first--);
  if (name[first]=='/' || name[first]=='\\') {
    first++;
  }

  // find the last ext seperator in name
  for (last=strlen(name)-1; 
       (name[last]!='.' && last);
       last--);
  if (!last) {
    last=strlen(name);
  }

  fprintf (stderr, "baseName: %s %d %d\n", name, first, last);
  // fill the base with the baseName
  for (i=first; i<last; i++) {
    base[i-first]=name[i];
  }
  base[i]='\0';
}
  
void readModule(char *module) {
  double hisVersion;
  char line[132];
  FILE *relModule;
  char moduleName[PATH_MAX];
  int areas, globals;
  int currentLine=1;

  if ((relModule=fopen(module, "r"))==NULL) {
    perror (module);
    exit (1);
  }
  printf ("ReadModule: %s\n", module);

  // first we need to check if this is a valid file
  if (sscanf(fgets(line, 132, relModule), 
	     "SDCCXA rel, version %lf", &hisVersion)!=1) {
    fprintf (stderr, "%s is not a valid input file\n", module);
    exit (1);
  }
  if (hisVersion!=version) {
    fprintf (stderr, "WARNING: version conflict; "
	     "we(%1.1f) != %s(%1.1f)\n", 
	     version, module, hisVersion);
  }
  currentLine++;
  
  // H 7 areas 168 global symbols
  if (sscanf(fgets(line, 132, relModule),
	     "H %d areas %d global symbols",
	     &areas, &globals)!=2) {
    syntaxError(line);
  }
  currentLine++;

  // M module
  if (sscanf(fgets(line, 132, relModule),
	     "M %s", moduleName)!=1) {
    syntaxError(line);
  }
  fprintf (stderr, "module %s has %d area%s and %d globals\n",
	   moduleName, areas, areas==1?"":"s", globals);
  currentLine++;

  // now for the ASTR tags
  while (fgets(line, 132, relModule)) {
    switch (line[0]) 
      {
      case 'A': {
	char area[32];
	int size, flags;
	if (sscanf(line, "A %[^ ] size %d flags %d",
		   area, &size, &flags)!=3) {
	  fprintf (stderr, "%s:%d error in A record line\n", module, 
		   currentLine);
	  exit (1);
	}
	// do we know this area?
	if (!(currentArea=getAreaID(area))) {
	  fprintf (stderr, "%s:%d unknown area: %s\n", module,
		   currentLine, area);
	  exit (1);
	}
	fprintf (stderr, "Area: %s size: %d\n", area, size);
	// never mind about the size and flags for now
	break;
      }
      case 'S': {
	char symbol[132];
	char refdef[132];
	unsigned int address;
	if (sscanf(line, "S %[^ ] %s", symbol, refdef)!=2) {
	  fprintf (stderr, "%s:%d syntax error near \"%s\"\n",
		   module, currentLine, line);
	  exit (1);
	}
	if (strncmp(refdef, "Ref", 3)==0) {
	  addToRefs(symbol);
	} else if (strncmp(refdef, "Def", 3)==0) {
	  sscanf (refdef, "Def%04x", &address);
	  addToDefs(symbol, address);
	} else {
	  fprintf (stderr, "%s:%d found invalid symbol definition \"%s\"\n", 
		   module, currentLine, line);
	  exit (1);
	}
	break;
      }
      case 'T': {
	unsigned int address;
	unsigned int byte;
	char *tline=NULL;
	if (sscanf(strtok(&line[2], " "), "%04x", &address)!=1) {
	  fprintf (stderr, "%s:%d error in T record\n", module, currentLine);
	  exit (1);
	}
	fprintf (stderr, "%04x:", address);
	for ( ;
	      (tline=strtok(NULL, " \t\n")) && 
		(sscanf(tline, "%02x", &byte)==1);
	      fprintf (stderr, " %02x", byte))
	  ; // how about that one, hey?
	fprintf (stderr, "\n");
	break;
      }
      case 'R':
	fprintf (stderr, "%s", line);
	break;
      default:
	fprintf (stderr, "%s:%d unknown record \"%s\"\n",
		 module, currentLine, line);
	break;
      }
    currentLine++;
  }
  // that's all for now, thanks for watching */
  fclose (relModule);
}

void writeModule() {
  fprintf (stderr, "WriteModule: %s\n", outFileName);
  // oops, forgot something :) */
}

void relocate() {
}

void usage (char * progName, int errNo) {
  fprintf (stderr, "usage: %s lnkCmdFile\n", progName);
  if (errNo) {
    exit (errNo);
  }
}

int main(int argc, char **argv) {
  FILE *linkCommandsFile;
  char linkCommandsPath[PATH_MAX];
  char linkCommand[PATH_MAX];

  if (argc!=2) {
    usage(argv[0], 1);
  }

  // read in the commands
  sprintf (linkCommandsPath, "%s.lnk", argv[1]);
  if (!(linkCommandsFile=fopen(linkCommandsPath, "r"))) {
    perror(linkCommandsPath);
    exit(1);
  }
  while (fgets(linkCommand, PATH_MAX, linkCommandsFile)) {
    linkCommand[strlen(linkCommand)-1]='\0';

    // skip empty lines
    if (!*linkCommand) {
      continue;
    }

    puts (linkCommand);
    if (*linkCommand=='-') {
      switch (linkCommand[1]) 
	{
	case 'm':
	  // probably -muxi, ignore for now
	  break;
	case 'e':
	  // -e, always in the last line, ignore for now
	  break;
	case 'b': 
	  {
	    // a segment start address like: "-b XSEG = 0x4000"
	    int s;
	    char *seg=strtok(&linkCommand[3], " \t");
	    for (s=0; s<MAX_SEGMENTS; s++) {
	      if (strcmp(segments[s].name, seg)==0) {
		strtok(NULL, " \t"); // skip the '='
		if (sscanf(strtok(NULL, " \t"), "%x", 
			   &segments[s].start)!=1) {
		  syntaxError(linkCommand);
		}
		fprintf (stderr, "%s starts at 0x%04x\n", segments[s].name,
			 segments[s].start);
		break;
	      }
	    }
	    if (s==MAX_SEGMENTS) {
	      syntaxError(linkCommand);
	    }
	  }
	  break;
	case 'k':
	  // a lib path like: "-k /usr/local/share/sdcc/lib/xa51"; one/line
	  libPaths[nlibPaths++]=strdup(&linkCommand[3]);
	  break;
	case 'l':
	  // a lib file like: "-l libsdcc"; one/line
	  libFiles[nlibFiles++]=strdup(&linkCommand[3]);
	  break;
	default:
	  syntaxError(linkCommand);
	}
    } else {
      // not a switch, must be an inputfile; one/line
      readModule(linkCommand);
    }
  }
  relocate();
  writeModule();
  return 0;
}

