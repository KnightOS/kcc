<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">

<!--Converted with LaTeX2HTML 99.1 release (March 30, 1999)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>SDCC Compiler User Guide</TITLE>
<META NAME="description" CONTENT="SDCC Compiler User Guide">
<META NAME="keywords" CONTENT="SDCCUdoc">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<META NAME="Generator" CONTENT="LaTeX2HTML v99.1 release">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="SDCCUdoc.css">

</HEAD>

<BODY >
<!--Navigation Panel-->
<IMG WIDTH="81" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next_group"
 SRC="/home/johan/latex2html/icons.gif/next_group_motif_gr.gif"> 
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up"
 SRC="/home/johan/latex2html/icons.gif/up_motif_gr.gif"> 
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous"
 SRC="/home/johan/latex2html/icons.gif/previous_motif_gr.gif">   
<BR>
<BR>
<BR>
<!--End of Navigation Panel-->

<P>

<P>
 
<H1 ALIGN="CENTER">SDCC Compiler User Guide</H1>
<BR>

<H2><A NAME="SECTION00010000000000000000">
Contents</A>
</H2>
<!--Table of Contents-->

<UL>
<LI><A NAME="tex2html124"
 HREF="SDCCUdoc.html">Contents</A>
<LI><A NAME="tex2html125"
 HREF="SDCCUdoc.html#SECTION00020000000000000000">1. Introduction</A>
<UL>
<LI><A NAME="tex2html126"
 HREF="SDCCUdoc.html#SECTION00021000000000000000">1.1 About SDCC</A>
<LI><A NAME="tex2html127"
 HREF="SDCCUdoc.html#SECTION00022000000000000000">1.2 Open Source</A>
<LI><A NAME="tex2html128"
 HREF="SDCCUdoc.html#SECTION00023000000000000000">1.3 Typographic conventions</A>
<LI><A NAME="tex2html129"
 HREF="SDCCUdoc.html#SECTION00024000000000000000">1.4 Compatibility with previous versions</A>
<LI><A NAME="tex2html130"
 HREF="SDCCUdoc.html#SECTION00025000000000000000">1.5 System Requirements</A>
<LI><A NAME="tex2html131"
 HREF="SDCCUdoc.html#SECTION00026000000000000000">1.6 Other Resources</A>
<LI><A NAME="tex2html132"
 HREF="SDCCUdoc.html#SECTION00027000000000000000">1.7 Wishes for the future</A>
</UL>
<LI><A NAME="tex2html133"
 HREF="SDCCUdoc.html#SECTION00030000000000000000">2. Installation</A>
<UL>
<LI><A NAME="tex2html134"
 HREF="SDCCUdoc.html#SECTION00031000000000000000">2.1 Linux/Unix Installation</A>
<LI><A NAME="tex2html135"
 HREF="SDCCUdoc.html#SECTION00032000000000000000">2.2 Windows Installation</A>
<LI><A NAME="tex2html136"
 HREF="SDCCUdoc.html#SECTION00033000000000000000">2.3 Testing out the SDCC Compiler</A>
<LI><A NAME="tex2html137"
 HREF="SDCCUdoc.html#SECTION00034000000000000000">2.4 Install Trouble-shooting</A>
<LI><A NAME="tex2html138"
 HREF="SDCCUdoc.html#SECTION00035000000000000000">2.5 Additional Information for Windows Users</A>
<LI><A NAME="tex2html139"
 HREF="SDCCUdoc.html#SECTION00036000000000000000">2.6 SDCC on Other Platforms</A>
<LI><A NAME="tex2html140"
 HREF="SDCCUdoc.html#SECTION00037000000000000000">2.7 Advanced Install Options</A>
<LI><A NAME="tex2html141"
 HREF="SDCCUdoc.html#SECTION00038000000000000000">2.8 Components of SDCC</A>
</UL>
<LI><A NAME="tex2html142"
 HREF="SDCCUdoc.html#SECTION00040000000000000000">3. Using SDCC</A>
<UL>
<LI><A NAME="tex2html143"
 HREF="SDCCUdoc.html#SECTION00041000000000000000">3.1 Compiling</A>
<LI><A NAME="tex2html144"
 HREF="SDCCUdoc.html#SECTION00042000000000000000">3.2 Command Line Options</A>
<LI><A NAME="tex2html145"
 HREF="SDCCUdoc.html#SECTION00043000000000000000">3.3 MCS51/DS390 Storage Class Language Extensions</A>
<LI><A NAME="tex2html146"
 HREF="SDCCUdoc.html#SECTION00044000000000000000">3.4 Pointers</A>
<LI><A NAME="tex2html147"
 HREF="SDCCUdoc.html#SECTION00045000000000000000">3.5 Parameters &amp; Local Variables</A>
<LI><A NAME="tex2html148"
 HREF="SDCCUdoc.html#SECTION00046000000000000000">3.6 Overlaying</A>
<LI><A NAME="tex2html149"
 HREF="SDCCUdoc.html#SECTION00047000000000000000">3.7 Interrupt Service Routines</A>
<LI><A NAME="tex2html150"
 HREF="SDCCUdoc.html#SECTION00048000000000000000">3.8 Critical Functions</A>
<LI><A NAME="tex2html151"
 HREF="SDCCUdoc.html#SECTION00049000000000000000">3.9 Naked Functions</A>
<LI><A NAME="tex2html152"
 HREF="SDCCUdoc.html#SECTION000410000000000000000">3.10 Functions using private banks</A>
<LI><A NAME="tex2html153"
 HREF="SDCCUdoc.html#SECTION000411000000000000000">3.11 Absolute Addressing</A>
<LI><A NAME="tex2html154"
 HREF="SDCCUdoc.html#SECTION000412000000000000000">3.12 Startup Code</A>
<LI><A NAME="tex2html155"
 HREF="SDCCUdoc.html#SECTION000413000000000000000">3.13 Inline Assembler Code</A>
<LI><A NAME="tex2html156"
 HREF="SDCCUdoc.html#SECTION000414000000000000000">3.14 int(16 bit) and long (32 bit) Support</A>
<LI><A NAME="tex2html157"
 HREF="SDCCUdoc.html#SECTION000415000000000000000">3.15 Floating Point Support</A>
<LI><A NAME="tex2html158"
 HREF="SDCCUdoc.html#SECTION000416000000000000000">3.16 MCS51 Memory Models</A>
<LI><A NAME="tex2html159"
 HREF="SDCCUdoc.html#SECTION000417000000000000000">3.17 DS390 Memory Models</A>
<LI><A NAME="tex2html160"
 HREF="SDCCUdoc.html#SECTION000418000000000000000">3.18 Defines Created by the Compiler</A>
</UL>
<LI><A NAME="tex2html161"
 HREF="SDCCUdoc.html#SECTION00050000000000000000">4. SDCC Technical Data</A>
<UL>
<LI><A NAME="tex2html162"
 HREF="SDCCUdoc.html#SECTION00051000000000000000">4.1 Optimizations</A>
<LI><A NAME="tex2html163"
 HREF="SDCCUdoc.html#SECTION00052000000000000000">4.2 Pragmas</A>
<LI><A NAME="tex2html164"
 HREF="SDCCUdoc.html#SECTION00053000000000000000">4.3 &lt;pending: this is messy and incomplete&gt; Library Routines</A>
<LI><A NAME="tex2html165"
 HREF="SDCCUdoc.html#SECTION00054000000000000000">4.4 Interfacing with Assembly Routines</A>
<LI><A NAME="tex2html166"
 HREF="SDCCUdoc.html#SECTION00055000000000000000">4.5 External Stack</A>
<LI><A NAME="tex2html167"
 HREF="SDCCUdoc.html#SECTION00056000000000000000">4.6 ANSI-Compliance</A>
<LI><A NAME="tex2html168"
 HREF="SDCCUdoc.html#SECTION00057000000000000000">4.7 Cyclomatic Complexity</A>
</UL>
<LI><A NAME="tex2html169"
 HREF="SDCCUdoc.html#SECTION00060000000000000000">5. TIPS</A>
<UL>
<LI><A NAME="tex2html170"
 HREF="SDCCUdoc.html#SECTION00061000000000000000">5.1 Notes on MCS51 memory layout</A>
</UL>
<LI><A NAME="tex2html171"
 HREF="SDCCUdoc.html#SECTION00070000000000000000">6. Retargetting for other MCUs.</A>
<LI><A NAME="tex2html172"
 HREF="SDCCUdoc.html#SECTION00080000000000000000">7. SDCDB - Source Level Debugger</A>
<UL>
<LI><A NAME="tex2html173"
 HREF="SDCCUdoc.html#SECTION00081000000000000000">7.1 Compiling for Debugging</A>
<LI><A NAME="tex2html174"
 HREF="SDCCUdoc.html#SECTION00082000000000000000">7.2 How the Debugger Works</A>
<LI><A NAME="tex2html175"
 HREF="SDCCUdoc.html#SECTION00083000000000000000">7.3 Starting the Debugger</A>
<LI><A NAME="tex2html176"
 HREF="SDCCUdoc.html#SECTION00084000000000000000">7.4 Command Line Options.</A>
<LI><A NAME="tex2html177"
 HREF="SDCCUdoc.html#SECTION00085000000000000000">7.5 Debugger Commands.</A>
<LI><A NAME="tex2html178"
 HREF="SDCCUdoc.html#SECTION00086000000000000000">7.6 Interfacing with XEmacs.</A>
</UL>
<LI><A NAME="tex2html179"
 HREF="SDCCUdoc.html#SECTION00090000000000000000">8. Other Processors</A>
<UL>
<LI><A NAME="tex2html180"
 HREF="SDCCUdoc.html#SECTION00091000000000000000">8.1 The Z80 and gbz80 port</A>
</UL>
<LI><A NAME="tex2html181"
 HREF="SDCCUdoc.html#SECTION000100000000000000000">9. Support</A>
<UL>
<LI><A NAME="tex2html182"
 HREF="SDCCUdoc.html#SECTION000101000000000000000">9.1 Reporting Bugs</A>
</UL>
<LI><A NAME="tex2html183"
 HREF="SDCCUdoc.html#SECTION000110000000000000000">10. Acknowledgments</A>
<LI><A NAME="tex2html184"
 HREF="SDCCUdoc.html#SECTION000120000000000000000">Index</A>
</UL>
<!--End of Table of Contents--> 

<P>

<H1><A NAME="SECTION00020000000000000000">
1. Introduction</A>
</H1>

<P>

<H2><A NAME="SECTION00021000000000000000">
1.1 About SDCC</A>
</H2>

<P>
 
<B>SDCC</B> is a Freeware, retargettable, optimizing ANSI-C compiler
by <B>Sandeep Dutta</B> designed for 8 bit Microprocessors. The
current version targets Intel MCS51 based Microprocessors(8051,8052,
etc), Zilog Z80 based MCUs, and the Dallas DS80C390 variant. It can
be retargetted for other microprocessors, support for PIC, AVR and
186 is under development. The entire source code for the compiler
is distributed under GPL. SDCC uses ASXXXX &amp; ASLINK, a Freeware,
retargettable assembler &amp; linker. SDCC has extensive language extensions
suitable for utilizing various microcontrollers and underlying hardware
effectively. 
<BR>

<BR>
In addition to the MCU specific optimizations SDCC also does a host
of standard optimizations like:

<P>

<UL>
<LI>global sub expression elimination, </LI>
<LI>loop optimizations (loop invariant, strength reduction of induction
variables and loop reversing), </LI>
<LI>constant folding &amp; propagation, </LI>
<LI>copy propagation, </LI>
<LI>dead code elimination </LI>
<LI>jumptables for <I>switch</I> statements.</LI>
</UL>
For the back-end SDCC uses a global register allocation scheme which
should be well suited for other 8 bit MCUs. 
<BR>

<BR>
The peep hole optimizer uses a rule based substitution mechanism which
is MCU independent. 
<BR>

<BR>
Supported data-types are:

<P>

<UL>
<LI>char (8 bits, 1 byte), </LI>
<LI>short and int (16 bits, 2 bytes), </LI>
<LI>long (32 bit, 4 bytes)</LI>
<LI>float (4 byte IEEE). </LI>
</UL>
The compiler also allows <I>inline assembler code</I> to be embedded
anywhere in a function. In addition, routines developed in assembly
can also be called.
<BR>

<BR>
SDCC also provides an option (-cyclomatic) to report the relative
complexity of a function. These functions can then be further optimized,
or hand coded in assembly if needed. 
<BR>

<BR>
SDCC also comes with a companion source level debugger SDCDB, the
debugger currently uses ucSim a freeware simulator for 8051 and other
micro-controllers. 
<BR>

<BR>
The latest version can be downloaded from  http://sdcc.sourceforge.net/<B>.</B>

<P>

<H2><A NAME="SECTION00022000000000000000">
1.2 Open Source</A>
</H2>

<P>
All packages used in this compiler system are <I>opensource</I> and
<I>freeware</I>; source code for all the sub-packages (asxxxx assembler/linker,
pre-processor) is distributed with the package. This documentation
is maintained using a freeware word processor (LYX). 

<P>
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published
by the Free Software Foundation; either version 2, or (at your option)
any later version. This program is distributed in the hope that it
will be useful, but WITHOUT ANY WARRANTY; without even the implied
warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See
the GNU General Public License for more details. You should have received
a copy of the GNU General Public License along with this program;
if not, write to the Free Software Foundation, 59 Temple Place - Suite
330, Boston, MA 02111-1307, USA. In other words, you are welcome to
use, share and improve this program. You are forbidden to forbid anyone
else to use, share and improve what you give them. Help stamp out
software-hoarding! 

<P>

<H2><A NAME="SECTION00023000000000000000">
1.3 Typographic conventions</A>
</H2>

<P>
Throughout this manual, we will use the following convention. Commands
you have to type in are printed in <I><B>&#34;sans
serif&#34;</B></I><I>.</I> Code samples are printed in <TT>typewriter
font.</TT> Interesting items and new terms are printed in <I>italicised
type.</I>

<P>

<H2><A NAME="SECTION00024000000000000000">
1.4 Compatibility with previous versions</A>
</H2>

<P>
This version has numerous bug fixes compared with the previous version.
But we also introduced some incompatibilities with older versions.
Not just for the fun of it, but to make the compiler more stable,
efficient and ANSI compliant. 
<BR>

<P>

<UL>
<LI>short is now equivalent to int (16 bits), it used to be equivalent
to char (8 bits)</LI>
<LI>the default directory where include, library and documention files
are stored is no in /usr/local/share</LI>
<LI>char type parameters to vararg functions are casted to int unless
explicitly casted, e.g.: 
<BR>
<TT>&nbsp;&nbsp;char a=3;</TT>&nbsp;
<BR>
<TT>&nbsp;&nbsp;printf (&#34;%d %c&#92;n&#34;,
a, (char)a);</TT>
<BR>
will push a as an int and as a char resp.</LI>
<LI>option -regextend has been removed</LI>
<LI>option -noreparms has been removed</LI>
</UL>
<I>&lt;pending: more incompatibilities?&gt;</I>

<P>

<H2><A NAME="SECTION00025000000000000000">
1.5 System Requirements</A>
</H2>

<P>
What do you need before you start installation of SDCC? A computer,
and a desire to compute. The preferred method of installation is to
compile SDCC from source using GNU gcc and make. For Windows some
pre-compiled binary distributions are available for your convenience.
You should have some experience with command line tools and compiler
use.

<P>

<H2><A NAME="SECTION00026000000000000000">
1.6 Other Resources</A>
</H2>

<P>
The SDCC home page at  http://sdcc.sourceforge.net/ is a great
place to find distribution sets. You can also find links to the user
mailing lists that offer help or discuss SDCC with other SDCC users.
Web links to other SDCC related sites can also be found here. This
document can be found in the DOC directory of the source package as
a text or HTML file. Some of the other tools (simulator and assembler)
included with SDCC contain their own documentation and can be found
in the source distribution. If you want the latest unreleased software,
the complete source package is available directly by anonymous CVS
on cvs.sdcc.sourceforge.net.

<P>

<H2><A NAME="SECTION00027000000000000000">
1.7 Wishes for the future</A>
</H2>

<P>
There are (and always will be) some things that could be done. Here
are some I can think of:
<BR>

<P>
 
<I><B>sdcc -c -model-large -o large _atoi.c</B></I> (where large
could be a different basename or a directory)
<BR>

<P>
 
<TT>char KernelFunction3(char p) at 0x340;</TT>&nbsp;
<BR>&nbsp;
<BR>
If you can think of some more, please send them to the list.
<BR>

<BR>
<I>&lt;pending: And then of course a proper index-table<A NAME="67"></A>&gt;</I>

<P>

<H1><A NAME="SECTION00030000000000000000">
2. Installation</A>
</H1>

<P>

<H2><A NAME="SECTION00031000000000000000">
2.1 Linux/Unix Installation</A>
</H2>

<P>

<OL>
<LI>Download the source package, it will be named something like sdcc-2.x.x.tgz.</LI>
<LI>Bring up a command line terminal, such as xterm.</LI>
<LI>Unpack the file using a command like: <I><B>&#34;tar
-xzf sdcc-2.x.x.tgz</B></I>&#34;, this will create a sub-directory
called sdcc with all of the sources.</LI>
<LI>Change directory into the main SDCC directory, for example type: <I><B>&#34;cd
sdcc</B></I><I>&#34;.</I></LI>
<LI>Type <I><B>&#34;./configure</B></I>&#34;. This configures
the package for compilation on your system.</LI>
<LI>Type <I><B>&#34;make</B></I>&#34;. All of the source
packages will compile, this can take a while.</LI>
<LI>Type <I><B>&#34;make install&#34;</B></I> as root. This
copies the binary executables, the include files, the libraries and
the documentation to the install directories.</LI>
</OL>

<P>

<H2><A NAME="SECTION00032000000000000000">
2.2 Windows Installation</A>
</H2>

<P>
 
<I>&lt;pending: is this complete? where is borland, mingw&gt;</I>
<BR>
<BR>
For installation under Windows you first need to pick between a pre-compiled
binary package, or installing the source package along with the Cygwin
package. The binary package is the quickest to install, while the
Cygwin package includes all of the open source power tools used to
compile the complete SDCC source package in the Windows environment.
If you are not familiar with the Unix command line environment, you
may want to read the section on additional information for Windows
users prior to your initial installation.

<P>

<H3><A NAME="SECTION00032100000000000000">
2.2.1 Windows Install Using a Binary Package</A>
</H3>

<P>

<OL>
<LI>Download the binary package and unpack it using your favorite unpacking
tool (gunzip, WinZip, etc). This should unpack to a group of sub-directories.
An example directory structure after unpacking is: c:&#92;usr&#92;local&#92;bin
for the executables, c:&#92;usr&#92;local&#92;share&#92;sdcc&#92;include
and c:&#92;usr&#92;local&#92;share&#92;sdcc&#92;lib
for the include and libraries.</LI>
<LI>Adjust your environment PATH to include the location of the bin directory.
For example, make a setsdcc.bat file with the following: set PATH=c:&#92;usr&#92;local&#92;bin;%PATH%</LI>
<LI>When you compile with sdcc, you may need to specify the location of
the lib and include folders. For example, sdcc -I c:&#92;usr&#92;local&#92;share&#92;sdcc&#92;include
-L c:&#92;usr&#92;local&#92;share&#92;sdcc&#92;lib&#92;small
test.c</LI>
</OL>

<P>

<H3><A NAME="SECTION00032200000000000000">
2.2.2 Windows Install Using Cygwin</A>
</H3>

<P>

<OL>
<LI>Download and install the cygwin package from the redhat site http://sources.redhat.com/cygwin/.
Currently, this involved downloading a small install program which
then automates downloading and installing selected parts of the package
(a large 80M byte sized dowload for the whole thing). </LI>
<LI>Bring up a Unix/Bash command line terminal from the Cygwin menu.</LI>
<LI>Follow the instructions in the preceding Linux/Unix installation section.</LI>
</OL>

<P>

<H2><A NAME="SECTION00033000000000000000">
2.3 Testing out the SDCC Compiler</A>
</H2>

<P>
The first thing you should do after installing your SDCC compiler
is to see if it runs. Type <I><B>&#34;sdcc -version&#34;</B></I>
at the prompt, and the program should run and tell you the version.
If it doesn't run, or gives a message about not finding sdcc program,
then you need to check over your installation. Make sure that the
sdcc bin directory is in your executable search path defined by the
PATH environment setting (see the Trouble-shooting section for suggestions).
Make sure that the sdcc program is in the bin folder, if not perhaps
something did not install correctly.
<BR>

<BR>
SDCC binaries are commonly installed in a directory arrangement like
this:
<BR>

<BR>
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT">/usr/local/bin</TD>
<TD ALIGN="LEFT">Holds executables(sdcc, s51, aslink, ...)</TD>
</TR>
<TR><TD ALIGN="LEFT">/usr/local/share/sdcc/lib</TD>
<TD ALIGN="LEFT">Holds common C libraries</TD>
</TR>
<TR><TD ALIGN="LEFT">/usr/local/share/sdcc/include</TD>
<TD ALIGN="LEFT">Holds common C header files</TD>
</TR>
</TABLE>
<BR>

<BR>
Make sure the compiler works on a very simple example. Type in the
following test.c program using your favorite editor:
<BR>
<BR>
<TT>int test(int t) {</TT>&nbsp;
<BR>
<TT>&nbsp;&nbsp;&nbsp;&nbsp;return t+3;</TT>&nbsp;
<BR>
<TT>}</TT>
<BR>
<BR>
Compile this using the following command: <I><B>&#34;sdcc
-c test.c&#34;.</B></I> If all goes well, the compiler will generate
a test.asm and test.rel file. Congratulations, you've just compiled
your first program with SDCC. We used the -c option to tell SDCC not
to link the generated code, just to keep things simple for this step.
<BR>

<BR>
The next step is to try it with the linker. Type in <I><B>&#34;sdcc
test.c</B></I>&#34;. If all goes well the compiler will link with the
libraries and produce a test.ihx output file. If this step fails (no
test.ihx, and the linker generates warnings), then the problem is
most likely that sdcc cannot find the /usr/local/share/sdcc/lib directory
(see the Install trouble-shooting section for suggestions).
<BR>

<BR>
The final test is to ensure sdcc can use the standard header files
and libraries. Edit test.c and change it to the following:
<BR>

<BR>
#include &lt;string.h&gt;
<BR>
main() {
<BR>
<TT>char str1[10];</TT>&nbsp;
<BR>
<TT>&nbsp;&nbsp;&nbsp;&nbsp;strcpy(str1, &#34;testing&#34;);</TT>&nbsp;
<BR>
<TT>}</TT>&nbsp;
<BR>&nbsp;
<BR>
Compile this by typing <I><B>&#34;sdcc test.c&#34;</B></I>.
This should generate a test.ihx output file, and it should give no
warnings such as not finding the string.h file. If it cannot find
the string.h file, then the problem is that sdcc cannot find the /usr/local/share/sdcc/include
directory (see the Install trouble-shooting section for suggestions).

<P>

<H2><A NAME="SECTION00034000000000000000">
2.4 Install Trouble-shooting</A>
</H2>

<P>

<H3><A NAME="SECTION00034100000000000000">
2.4.1 SDCC cannot find libraries or header files.</A>
</H3>

<P>
The default installation assumes the libraries and header files are
located at ``/usr/local/share/sdcc/lib'' and ``/usr/local/share/sdcc/include''.
An alternative is to specify these locations as compiler options like
this: <I><B>&#34;sdcc&nbsp;-L&nbsp;/usr/local/sdcc/lib/small&nbsp;-I&nbsp;/usr/local/sdcc/include&nbsp;test.c&#34;</B></I>.

<P>

<H3><A NAME="SECTION00034200000000000000">
2.4.2 SDCC does not compile correctly.</A>
</H3>

<P>
A thing to try is starting from scratch by unpacking the .tgz source
package again in an empty directory. Confure it again and build like:
<BR>

<BR>
<I><B>make 2SPMamp;&gt;1 | tee make.log</B></I>
<BR>

<BR>
After this you can review the make.log file to locate the problem.
Or a relevant part of this be attached to an email that could be helpful
when requesting help from the mailing list.

<P>

<H3><A NAME="SECTION00034300000000000000">
2.4.3 What the ''./configure'' does</A>
</H3>

<P>
The ''./configure'' command is a script that analyzes your system
and performs some configuration to ensure the source package compiles
on your system. It will take a few minutes to run, and will compile
a few tests to determine what compiler features are installed.

<P>

<H3><A NAME="SECTION00034400000000000000">
2.4.4 What the ''make'' does.</A>
</H3>

<P>
This runs the GNU make tool, which automatically compiles all the
source packages into the final installed binary executables.

<P>

<H3><A NAME="SECTION00034500000000000000">
2.4.5 What the ''make install'' command does.</A>
</H3>

<P>
This will install the compiler, other executables and libraries in
to the appropriate system directories. The default is to copy the
executables to /usr/local/bin and the libraries and header files to
/usr/local/share/sdcc/lib and /usr/local/share/sdcc/include.

<P>

<H2><A NAME="SECTION00035000000000000000">
2.5 Additional Information for Windows Users</A>
</H2>

<P>
 
<I>&lt;pending: is this up to date?&gt;</I>
<BR>
<BR>
The standard method of installing on a Unix system involves compiling
the source package. This is easily done under Unix, but under Windows
it can be a more difficult process. The Cygwin is a large package
to download, and the compilation runs considerably slower under Windows
due to the overhead of the Cygwin tool set. An alternative is to install
a pre-compiled Windows binary package. There are various trade-offs
between each of these methods. 

<P>
The Cygwin package allows a Windows user to run a Unix command line
interface (bash shell) and also implements a Unix like file system
on top of Windows. Included are many of the famous GNU software development
tools which can augment the SDCC compiler.This is great if you have
some experience with Unix command line tools and file system conventions,
if not you may find it easier to start by installing a binary Windows
package. The binary packages work with the Windows file system conventions.

<P>

<H3><A NAME="SECTION00035100000000000000">
2.5.1 Getting started with Cygwin</A>
</H3>

<P>
SDCC is typically distributed as a tarred/gzipped file (.tgz). This
is a packed file similar to a .zip file. Cygwin includes the tools
you will need to unpack the SDCC distribution (tar and gzip). To unpack
it, simply follow the instructions under the Linux/Unix install section.
Before you do this you need to learn how to start a cygwin shell and
some of the basic commands used to move files, change directory, run
commands and so on. The change directory command is <I><B>``cd''</B></I>,
the move command is <I><B>``mv''</B></I>. To print the current
working directory, type <I><B>``pwd''</B></I>. To make a directory,
use <I><B>``mkdir''</B></I>.

<P>
There are some basic differences between Unix and Windows file systems
you should understand. When you type in directory paths, Unix and
the Cygwin bash prompt uses forward slashes '/' between directories
while Windows traditionally uses '&#92;' backward slashes.
So when you work at the Cygwin bash prompt, you will need to use the
forward '/' slashes. Unix does not have a concept of drive letters,
such as ``c:``, instead all files systems attach and appear
as directories.

<P>

<H3><A NAME="SECTION00035200000000000000">
2.5.2 Running SDCC as Native Compiled Executables</A>
</H3>

<P>
If you use the pre-compiled binaries, the install directories for
the libraries and header files may need to be specified on the sdcc
command line like this: <I><B>&#34;sdcc -L c:&#92;usr&#92;local&#92;sdcc&#92;lib&#92;small
-I c:&#92;usr&#92;local&#92;sdcc&#92;include
test.c&#34;</B></I> if you are running outside of a Unix bash shell.

<P>
If you have successfully installed and compiled SDCC with the Cygwin
package, it is possible to compile into native .exe files by using
the additional makefiles included for this purpose. For example, with
the Borland 32-bit compiler you would run <I><B>&#34;make
-f Makefile.bcc&#34;</B></I>. A command line version of the Borland
32-bit compiler can be downloaded from the Inprise web site.

<P>

<H2><A NAME="SECTION00036000000000000000">
2.6 SDCC on Other Platforms</A>
</H2>

<P>

<UL>
<LI><B>FreeBSD and other non-GNU Unixes</B> - Make sure the GNU make
is installed as the default make tool.</LI>
<LI>SDCC has been ported to run under a variety of operating systems and
processors. If you can run GNU GCC/make then chances are good SDCC
can be compiled and run on your system.</LI>
</UL>

<P>

<H2><A NAME="SECTION00037000000000000000">
2.7 Advanced Install Options</A>
</H2>

<P>
The ``configure'' command has several options. The most commonly
used option is -prefix=&lt;directory name&gt;, where &lt;directory name&gt; is
the final location for the sdcc executables and libraries, (default
location is /usr/local). The installation process will create the
following directory structure under the &lt;directory name&gt; specified
(if they do not already exist). 
<BR>

<BR>
bin/ - binary exectables (add to PATH environment variable)
<BR>
bin/share/
<BR>
bin/share/sdcc/include/ - include header files
<BR>
bin/share/sdcc/lib/
<BR>
bin/share/sdcc/lib/small/ - Object &amp; library files for small model
library
<BR>
bin/share/sdcc/lib/large/ - Object &amp; library files for large model
library
<BR>
bin/share/sdcc/lib/ds390/ - Object &amp; library files forDS80C390 library
<BR>

<BR>
The command <I><B>''./configure -prefix=/usr/local''</B></I>
will configure the compiler to be installed in directory /usr/local.

<P>

<H2><A NAME="SECTION00038000000000000000">
2.8 Components of SDCC</A>
</H2>

<P>
SDCC is not just a compiler, but a collection of tools by various
developers. These include linkers, assemblers, simulators and other
components. Here is a summary of some of the components. Note that
the included simulator and assembler have separate documentation which
you can find in the source package in their respective directories.
As SDCC grows to include support for other processors, other packages
from various developers are included and may have their own sets of
documentation.
<BR>

<BR>
You might want to look at the files which are installed in &lt;installdir&gt;.
At the time of this writing, we find the following programs:
<BR>
 
<BR>
In &lt;installdir&gt;/bin:

<P>

<UL>
<LI>sdcc - The compiler.</LI>
<LI>sdcpp - The C preprocessor.</LI>
<LI>asx8051 - The assembler for 8051 type processors.</LI>
<LI>as-z80<B>,</B> as-gbz80 - The Z80 and GameBoy Z80 assemblers.</LI>
<LI>aslink -The linker for 8051 type processors.</LI>
<LI>link-z80<B>,</B> link-gbz80 - The Z80 and GameBoy Z80 linkers.</LI>
<LI>s51 - The ucSim 8051 simulator.</LI>
<LI>sdcdb - The source debugger.</LI>
<LI>packihx - A tool to pack Intel hex files.</LI>
</UL>
In &lt;installdir&gt;/share/sdcc/include

<P>

<UL>
<LI>the include files</LI>
</UL>
In &lt;installdir&gt;/share/sdcc/lib

<P>

<UL>
<LI>the sources of the runtime library and the subdirs small large and
ds390 with the precompiled relocatables.</LI>
</UL>
In &lt;installdir&gt;/share/sdcc/doc

<P>

<UL>
<LI>the documentation</LI>
</UL>
As development for other processors proceeds, this list will expand
to include executables to support processors like AVR, PIC, etc.

<P>

<H3><A NAME="SECTION00038100000000000000">
2.8.1 sdcc - The Compiler</A>
</H3>

<P>
This is the actual compiler, it in turn uses the c-preprocessor and
invokes the assembler and linkage editor.

<P>

<H3><A NAME="SECTION00038200000000000000">
2.8.2 sdcpp (C-Preprocessor)</A>
</H3>

<P>
The preprocessor is a modified version of the GNU preprocessor. The
C preprocessor is used to pull in #include sources, process #ifdef
statements, #defines and so on.

<P>

<H3><A NAME="SECTION00038300000000000000">
2.8.3 asx8051, as-z80, as-gbz80, aslink, link-z80, link-gbz80 (The Assemblers
and Linkage Editors)</A>
</H3>

<P>
This is retargettable assembler &amp; linkage editor, it was developed
by Alan Baldwin. John Hartman created the version for 8051, and I
(Sandeep) have made some enhancements and bug fixes for it to work
properly with the SDCC.

<P>

<H3><A NAME="SECTION00038400000000000000">
2.8.4 s51 - Simulator</A>
</H3>

<P>
S51 is a freeware, opensource simulator developed by Daniel Drotos
( mailto:drdani@mazsola.iit.uni-miskolc.hu). The simulator is
built as part of the build process. For more information visit Daniel's
website at:  http://mazsola.iit.uni-miskolc.hu/&nbsp;drdani/embedded/s51
.

<P>

<H3><A NAME="SECTION00038500000000000000">
2.8.5 sdcdb - Source Level Debugger</A>
</H3>

<P>
Sdcdb is the companion source level debugger. The current version
of the debugger uses Daniel's Simulator S51, but can be easily changed
to use other simulators.

<P>

<H1><A NAME="SECTION00040000000000000000">
3. Using SDCC</A>
</H1>

<P>

<H2><A NAME="SECTION00041000000000000000">
3.1 Compiling</A>
</H2>

<P>

<H3><A NAME="SECTION00041100000000000000">
3.1.1 Single Source File Projects</A>
</H3>

<P>
For single source file 8051 projects the process is very simple. Compile
your programs with the following command <I><B>&#34;sdcc
sourcefile.c&#34;.</B></I> This will compile, assemble and link your
source file. Output files are as follows
<BR>

<BR>
sourcefile.asm - Assembler source file created by the compiler
<BR>
sourcefile.lst - Assembler listing file created by the Assembler
<BR>
sourcefile.rst - Assembler listing file updated with linkedit information,
created by linkage editor
<BR>
sourcefile.sym - symbol listing for the sourcefile, created by the
assembler
<BR>
sourcefile.rel - Object file created by the assembler, input to Linkage
editor
<BR>
sourcefile.map - The memory map for the load module, created by the
Linker
<BR>
sourcefile.ihx - The load module in Intel hex format (you can select
the Motorola S19 format with -out-fmt-s19)
<BR>
sourcefile.cdb - An optional file (with -debug) containing debug
information
<BR>

<P>

<H3><A NAME="SECTION00041200000000000000">
3.1.2 Projects with Multiple Source Files</A>
</H3>

<P>
SDCC can compile only ONE file at a time. Let us for example assume
that you have a project containing the following files:
<BR>

<BR>
foo1.c (contains some functions)
<BR>
foo2.c (contains some more functions)
<BR>
foomain.c (contains more functions and the function main)
<BR>

<BR>
The first two files will need to be compiled separately with the commands:

<BR>

<BR>
<I><B>sdcc&nbsp;-c&nbsp;foo1.c</B></I>
<BR>
<I><B>sdcc&nbsp;-c&nbsp;foo2.c</B></I>
<BR>

<BR>
Then compile the source file containing the <I>main()</I> function
and link the files together with the following command: 
<BR>

<BR>
<I><B>sdcc&nbsp;foomain.c&nbsp;foo1.rel&nbsp;foo2.rel</B></I>
<BR>

<BR>
Alternatively, <I>foomain.c</I> can be separately compiled as well:
<BR>
<BR>
<I><B>sdcc&nbsp;-c&nbsp;foomain.c</B></I>
<BR>
<I><B>sdcc foomain.rel foo1.rel foo2.rel</B></I>
<BR>
<BR>
The file containing the <I>main()</I> function <SMALL>MUST</SMALL>
be the <SMALL>FIRST</SMALL> file specified in the command line, since the
linkage editor processes file in the order they are presented to it.

<P>

<H3><A NAME="SECTION00041300000000000000">
3.1.3 Projects with Additional Libraries</A>
</H3>

<P>
Some reusable routines may be compiled into a library, see the documentation
for the assembler and linkage editor (which are in &lt;installdir&gt;/share/sdcc/doc)
for how to create a <I>.lib</I> library file. Libraries created in
this manner can be included in the command line. Make sure you include
the -L &lt;library-path&gt; option to tell the linker where to look for
these files if they are not in the current directory. Here is an example,
assuming you have the source file <I>foomain.c</I> and a library <I>foolib.lib</I>
in the directory <I>mylib</I> (if that is not the same as your current
project):
<BR>

<BR>
<I><B>sdcc foomain.c foolib.lib -L mylib</B></I>
<BR>
<BR>
Note here that <I>mylib</I> must be an absolute path name.
<BR>

<BR>
The most efficient way to use libraries is to keep seperate modules
in seperate source files. The lib file now should name all the modules.rel
files. For an example see the standard library file <I>libsdcc.lib</I>
in the directory &lt;installdir&gt;/share/lib/small.

<P>

<H2><A NAME="SECTION00042000000000000000">
3.2 Command Line Options</A>
</H2>

<P>

<H3><A NAME="SECTION00042100000000000000">
3.2.1 Processor Selection Options</A>
</H3>

<P>

<UL>
<LI>[<B>-mmcs51</B>]Generate code for the MCS51 (8051) family of processors.
This is the default processor target.</LI>
<LI>[<B>-mds390</B>]Generate code for the DS80C390 processor.</LI>
<LI>[<B>-mz80</B>]Generate code for the Z80 family of processors.</LI>
<LI>[<B>-mgbz80</B>]Generate code for the GameBoy Z80 processor.</LI>
<LI>[<B>-mavr</B>]Generate code for the Atmel AVR processor(In development,
not complete).</LI>
<LI>[<B>-mpic14</B>]Generate code for the PIC 14-bit processors(In development,
not complete).</LI>
<LI>[<B>-mtlcs900h</B>]Generate code for the Toshiba TLCS-900H processor(In
development, not complete).</LI>
</UL>
<P>

<H3><A NAME="SECTION00042200000000000000">
3.2.2 Preprocessor Options</A>
</H3>

<P>

<UL>
<LI>[<B>-I&lt;path&gt;</B>]The additional location where the pre processor
will look for &lt;..h&gt; or ``..h'' files.</LI>
<LI>[<B>-D&lt;macro[=value]&gt;</B>]Command line definition of macros.
Passed to the pre processor.</LI>
<LI>[<B>-M</B>]Tell the preprocessor to output a rule suitable for make
describing the dependencies of each object file. For each source file,
the preprocessor outputs one make-rule whose target is the object
file name for that source file and whose dependencies are all the
files `#include'd in it. This rule may be a single line or may be
continued with `&#92;'-newline if it is long. The list
of rules is printed on standard output instead of the preprocessed
C program. `-M' implies `-E'.</LI>
<LI>[<B>-C</B>]Tell the preprocessor not to discard comments. Used with
the `-E' option.</LI>
<LI>[<B>-MM</B>]Like `-M' but the output mentions only the user header
files included with `#include ``file&#34;'. System header
files included with `#include &lt;file&gt;' are omitted.</LI>
<LI>[<B>-Aquestion(answer)</B>]Assert the answer answer for question,
in case it is tested with a preprocessor conditional such as `#if
#question(answer)'. `-A-' disables the standard assertions that normally
describe the target machine.</LI>
<LI>[<B>-Aquestion</B>](answer) Assert the answer answer for question,
in case it is tested with a preprocessor conditional such as `#if
#question(answer)'. `-A-' disables the standard assertions that normally
describe the target machine.</LI>
<LI>[<B>-Umacro</B>]Undefine macro macro. `-U' options are evaluated
after all `-D' options, but before any `-include' and `-imacros' options.</LI>
<LI>[<B>-dM</B>]Tell the preprocessor to output only a list of the macro
definitions that are in effect at the end of preprocessing. Used with
the `-E' option.</LI>
<LI>[<B>-dD</B>]Tell the preprocessor to pass all macro definitions
into the output, in their proper sequence in the rest of the output.</LI>
<LI>[<B>-dN</B>]Like `-dD' except that the macro arguments and contents
are omitted. Only `#define name' is included in the output.</LI>
</UL>
<P>

<H3><A NAME="SECTION00042300000000000000">
3.2.3 Linker Options</A>
</H3>

<P>

<UL>
<LI>[<B>-L&nbsp;-lib-path</B>]&lt;absolute path to additional libraries&gt; This
option is passed to the linkage editor's additional libraries search
path. The path name must be absolute. Additional library files may
be specified in the command line. See section Compiling programs for
more details.</LI>
<LI>[<B>-xram-loc</B>&lt;Value&gt;]The start location of the external ram,
default value is 0. The value entered can be in Hexadecimal or Decimal
format, e.g.: -xram-loc 0x8000 or -xram-loc 32768.</LI>
<LI>[<B>-code-loc</B>&lt;Value&gt;]The start location of the code segment,
default value 0. Note when this option is used the interrupt vector
table is also relocated to the given address. The value entered can
be in Hexadecimal or Decimal format, e.g.: -code-loc 0x8000 or -code-loc
32768.</LI>
<LI>[<B>-stack-loc</B>&lt;Value&gt;]The initial value of the stack pointer.
The default value of the stack pointer is 0x07 if only register bank
0 is used, if other register banks are used then the stack pointer
is initialized to the location above the highest register bank used.
eg. if register banks 1 &amp; 2 are used the stack pointer will default
to location 0x18. The value entered can be in Hexadecimal or Decimal
format, eg. -stack-loc 0x20 or -stack-loc 32. If all four register
banks are used the stack will be placed after the data segment (equivalent
to -stack-after-data)</LI>
<LI>[<B>-stack-after-data</B>]This option will cause the stack to be
located in the internal ram after the data segment.</LI>
<LI>[<B>-data-loc</B>&lt;Value&gt;]The start location of the internal ram
data segment, the default value is 0x30.The value entered can be in
Hexadecimal or Decimal format, eg. -data-loc 0x20 or -data-loc 32.</LI>
<LI>[<B>-idata-loc</B>&lt;Value&gt;]The start location of the indirectly
addressable internal ram, default value is 0x80. The value entered
can be in Hexadecimal or Decimal format, eg. -idata-loc 0x88 or -idata-loc
136.</LI>
<LI>[<B>-out-fmt-ihx</B>]The linker output (final object code) is in
Intel Hex format. (This is the default option).</LI>
<LI>[<B>-out-fmt-s19</B>]The linker output (final object code) is in
Motorola S19 format.</LI>
</UL>
<P>

<H3><A NAME="SECTION00042400000000000000">
3.2.4 MCS51 Options</A>
</H3>

<P>

<UL>
<LI>[<B>-model-large</B>]Generate code for Large model programs see
section Memory Models for more details. If this option is used all
source files in the project should be compiled with this option. In
addition the standard library routines are compiled with small model,
they will need to be recompiled.</LI>
<LI>[<B>-model-small</B>]Generate code for Small Model programs see
section Memory Models for more details. This is the default model.</LI>
</UL>
<P>

<H3><A NAME="SECTION00042500000000000000">
3.2.5 DS390 Options</A>
</H3>

<P>

<UL>
<LI>[<B>-model-flat24</B>]Generate 24-bit flat mode code. This is the
one and only that the ds390 code generator supports right now and
is default when using <I>-mds390</I>. See section Memory Models for
more details.</LI>
<LI>[<B>-stack-10bit</B>]Generate code for the 10 bit stack mode of
the Dallas DS80C390 part. This is the one and only that the ds390
code generator supports right now and is default when using <I>-mds390</I>.
In this mode, the stack is located in the lower 1K of the internal
RAM, which is mapped to 0x400000. Note that the support is incomplete,
since it still uses a single byte as the stack pointer. This means
that only the lower 256 bytes of the potential 1K stack space will
actually be used. However, this does allow you to reclaim the precious
256 bytes of low RAM for use for the DATA and IDATA segments. The
compiler will not generate any code to put the processor into 10 bit
stack mode. It is important to ensure that the processor is in this
mode before calling any re-entrant functions compiled with this option.
In principle, this should work with the <I>-stack-auto</I> option,
but that has not been tested. It is incompatible with the <I>-xstack</I>
option. It also only makes sense if the processor is in 24 bit contiguous
addressing mode (see the <I>-model-flat24 option</I>).</LI>
</UL>
<P>

<H3><A NAME="SECTION00042600000000000000">
3.2.6 Optimization Options</A>
</H3>

<P>

<UL>
<LI>[<B>-nogcse</B>]Will not do global subexpression elimination, this
option may be used when the compiler creates undesirably large stack/data
spaces to store compiler temporaries. A warning message will be generated
when this happens and the compiler will indicate the number of extra
bytes it allocated. It recommended that this option NOT be used, #pragma&nbsp;NOGCSE
can be used to turn off global subexpression elimination for a given
function only.</LI>
<LI>[<B>-noinvariant</B>]Will not do loop invariant optimizations,
this may be turned off for reasons explained for the previous option.
For more details of loop optimizations performed see section Loop
Invariants.It recommended that this option NOT be used, #pragma&nbsp;NOINVARIANT
can be used to turn off invariant optimizations for a given function
only.</LI>
<LI>[<B>-noinduction</B>]Will not do loop induction optimizations,
see section strength reduction for more details.It is recommended
that this option is NOT used, #pragma&nbsp;NOINDUCTION can be used to
turn off induction optimizations for a given function only.</LI>
<LI>[<B>-nojtbound</B>] Will not generate boundary condition check
when switch statements are implemented using jump-tables. See section
Switch Statements for more details. It is recommended that this option
is NOT used, #pragma&nbsp;NOJTBOUND can be used to turn off boundary
checking for jump tables for a given function only.</LI>
<LI>[<B>-noloopreverse</B>]Will not do loop reversal optimization.</LI>
</UL>
<P>

<H3><A NAME="SECTION00042700000000000000">
3.2.7 Other Options</A>
</H3>

<P>

<UL>
<LI>[<B>-c&nbsp;-compile-only</B>]will compile and assemble the source,
but will not call the linkage editor.</LI>
<LI>[<B>-E</B>]Run only the C preprocessor. Preprocess all the C source
files specified and output the results to standard output.</LI>
<LI>[<B>-stack-auto</B>]All functions in the source file will be compiled
as <I>reentrant</I>, i.e. the parameters and local variables will
be allocated on the stack. see section Parameters and Local Variables
for more details. If this option is used all source files in the project
should be compiled with this option. </LI>
<LI>[<B>-xstack</B>]Uses a pseudo stack in the first 256 bytes in the
external ram for allocating variables and passing parameters. See
section on external stack for more details.</LI>
<LI>[<B>-callee-saves</B>]<B>function1[,function2][,function3]....</B>
The compiler by default uses a caller saves convention for register
saving across function calls, however this can cause unneccessary
register pushing &amp; popping when calling small functions from larger
functions. This option can be used to switch the register saving convention
for the function names specified. The compiler will not save registers
when calling these functions, no extra code will be generated at the
entry &amp; exit for these functions to save &amp; restore the registers
used by these functions, this can SUBSTANTIALLY reduce code &amp; improve
run time performance of the generated code. In the future the compiler
(with interprocedural analysis) will be able to determine the appropriate
scheme to use for each function call. DO NOT use this option for built-in
functions such as _muluint..., if this option is used for a library
function the appropriate library function needs to be recompiled with
the same option. If the project consists of multiple source files
then all the source file should be compiled with the same -callee-saves
option string. Also see #pragma&nbsp;CALLEE-SAVES.</LI>
<LI>[<B>-debug</B>]When this option is used the compiler will generate
debug information, that can be used with the SDCDB. The debug information
is collected in a file with .cdb extension. For more information see
documentation for SDCDB.</LI>
<LI>[<B><I>-regextend</I></B>] <I>This option is obsolete and isn't
supported anymore.</I></LI>
<LI>[<B><I>-noregparms</I></B>]<I>This option is obsolete and isn't
supported anymore.</I></LI>
<LI>[<B>-peep-file</B>&lt;filename&gt;]This option can be used to use additional
rules to be used by the peep hole optimizer. See section Peep Hole
optimizations for details on how to write these rules.</LI>
<LI>[<B>-S</B>]Stop after the stage of compilation proper; do not assemble.
The output is an assembler code file for the input file specified.</LI>
<LI>[<B>-Wa_asmOption[,asmOption]</B>...]Pass the asmOption to
the assembler.</LI>
<LI>[<B>-Wl_linkOption[,linkOption]</B>...]Pass the linkOption
to the linker.</LI>
<LI>[<B>-int-long-reent</B>] Integer (16 bit) and long (32 bit) libraries
have been compiled as reentrant. Note by default these libraries are
compiled as non-reentrant. See section Installation for more details.</LI>
<LI>[<B>-cyclomatic</B>]This option will cause the compiler to generate
an information message for each function in the source file. The message
contains some <I>important</I> information about the function. The
number of edges and nodes the compiler detected in the control flow
graph of the function, and most importantly the <I>cyclomatic complexity</I>
see section on Cyclomatic Complexity for more details.</LI>
<LI>[<B>-float-reent</B>] Floating point library is compiled as reentrant.See
section Installation for more details.</LI>
<LI>[<B>-nooverlay</B>] The compiler will not overlay parameters and
local variables of any function, see section Parameters and local
variables for more details.</LI>
<LI>[<B>-main-return</B>]This option can be used when the code generated
is called by a monitor program. The compiler will generate a 'ret'
upon return from the 'main' function. The default option is to lock
up i.e. generate a 'ljmp '.</LI>
<LI>[<B>-no-peep</B>] Disable peep-hole optimization.</LI>
<LI>[<B>-peep-asm</B>] Pass the inline assembler code through the peep
hole optimizer. This can cause unexpected changes to inline assembler
code, please go through the peephole optimizer rules defined in the
source file tree '&lt;target&gt;/peeph.def' before using this option.</LI>
<LI>[<B>-iram-size</B>&lt;Value&gt;]Causes the linker to check if the interal
ram usage is within limits of the given value.</LI>
<LI>[<B>-nostdincl</B>]This will prevent the compiler from passing
on the default include path to the preprocessor.</LI>
<LI>[<B>-nostdlib</B>]This will prevent the compiler from passing on
the default library path to the linker.</LI>
<LI>[<B>-verbose</B>]Shows the various actions the compiler is performing.</LI>
<LI>[<B>-V</B>]Shows the actual commands the compiler is executing.</LI>
</UL>
<P>

<H3><A NAME="SECTION00042800000000000000">
3.2.8 Intermediate Dump Options</A>
</H3>

<P>
The following options are provided for the purpose of retargetting
and debugging the compiler. These provided a means to dump the intermediate
code (iCode) generated by the compiler in human readable form at various
stages of the compilation process. 

<P>

<UL>
<LI>[<B>-dumpraw</B>]This option will cause the compiler to dump the
intermediate code into a file of named <I>&lt;source filename&gt;.dumpraw</I>
just after the intermediate code has been generated for a function,
i.e. before any optimizations are done. The basic blocks at this stage
ordered in the depth first number, so they may not be in sequence
of execution.</LI>
<LI>[<B>-dumpgcse</B>]Will create a dump of iCode's, after global subexpression
elimination, into a file named <I>&lt;source filename&gt;.dumpgcse.</I></LI>
<LI>[<B>-dumpdeadcode</B>]Will create a dump of iCode's, after deadcode
elimination, into a file named <I>&lt;source filename&gt;.dumpdeadcode.</I></LI>
<LI>[<B>-dumploop</B>]Will create a dump of iCode's, after loop optimizations,
into a file named <I>&lt;source filename&gt;.dumploop.</I></LI>
<LI>[<B>-dumprange</B>]Will create a dump of iCode's, after live range
analysis, into a file named <I>&lt;source filename&gt;.dumprange.</I></LI>
<LI>[<B>-dumlrange</B>]Will dump the life ranges for all symbols.</LI>
<LI>[<B>-dumpregassign</B>]Will create a dump of iCode's, after register
assignment, into a file named <I>&lt;source filename&gt;.dumprassgn.</I></LI>
<LI>[<B>-dumplrange</B>]Will create a dump of the live ranges of iTemp's</LI>
<LI>[<B>-dumpall</B>]Will cause all the above mentioned dumps to be
created.</LI>
</UL>
<P>

<H2><A NAME="SECTION00043000000000000000">
3.3 MCS51/DS390 Storage Class Language Extensions</A>
</H2>

<P>
In addition to the ANSI storage classes SDCC allows the following
MCS51 specific storage classes.

<P>

<H3><A NAME="SECTION00043100000000000000">
3.3.1 xdata</A>
</H3>

<P>
Variables declared with this storage class will be placed in the extern
RAM. This is the <B>default</B> storage class for Large Memory model,
e.g.:
<BR>

<BR>
<TT>xdata unsigned char xduc;</TT>

<P>

<H3><A NAME="SECTION00043200000000000000">
3.3.2 data</A>
</H3>

<P>
This is the <B>default</B> storage class for Small Memory model.
Variables declared with this storage class will be allocated in the
internal RAM, e.g.:
<BR>

<BR>
<TT>data int iramdata;</TT>

<P>

<H3><A NAME="SECTION00043300000000000000">
3.3.3 idata</A>
</H3>

<P>
Variables declared with this storage class will be allocated into
the indirectly addressable portion of the internal ram of a 8051,
e.g.:
<BR>

<BR>
<TT>idata int idi;</TT>

<P>

<H3><A NAME="SECTION00043400000000000000">
3.3.4 bit</A>
</H3>

<P>
This is a data-type and a storage class specifier. When a variable
is declared as a bit, it is allocated into the bit addressable memory
of 8051, e.g.:
<BR>

<BR>
<TT>bit iFlag;</TT>

<P>

<H3><A NAME="SECTION00043500000000000000">
3.3.5 sfr / sbit</A>
</H3>

<P>
Like the bit keyword, <I>sfr / sbit</I> signifies both a data-type
and storage class, they are used to describe the special function
registers and special bit variables of a 8051, eg:
<BR>

<BR>
<TT>sfr at 0x80 P0; /* special function register P0 at location
0x80 */</TT>&nbsp;
<BR>
<TT>sbit at 0xd7 CY; /* CY (Carry Flag) */</TT>

<P>

<H2><A NAME="SECTION00044000000000000000">
3.4 Pointers</A>
</H2>

<P>
SDCC allows (via language extensions) pointers to explicitly point
to any of the memory spaces of the 8051. In addition to the explicit
pointers, the compiler also allows a <I>_generic</I> class of pointers
which can be used to point to any of the memory spaces.
<BR>

<BR>
Pointer declaration examples:
<BR>

<BR>
<TT>/* pointer physically in xternal ram pointing to object
in internal ram */ </TT>&nbsp;
<BR>
<TT>data unsigned char * xdata p;</TT>&nbsp;
<BR>&nbsp;
<BR>
<TT>/* pointer physically in code rom pointing to data in xdata
space */ </TT>&nbsp;
<BR>
<TT>xdata unsigned char * code p;</TT>&nbsp;
<BR>&nbsp;
<BR>
<TT>/* pointer physically in code space pointing to data in
code space */ </TT>&nbsp;
<BR>
<TT>code unsigned char * code p;</TT>&nbsp;
<BR>&nbsp;
<BR>
<TT>/* the folowing is a generic pointer physically located
in xdata space */</TT>&nbsp;
<BR>
<TT>char * xdata p;</TT>
<BR>

<BR>
Well you get the idea. 
<BR>

<BR>
<I>For compatibility with the previous version of the compiler,
the following syntax for pointer declaration is still supported but
will disappear int the near future. </I>
<BR>
<BR>
<TT><I>unsigned char _xdata *ucxdp; /* pointer to data
in external ram */ </I></TT>&nbsp;
<BR>
<TT><I>unsigned char _data &nbsp;*ucdp ; /* pointer to data
in internal ram */ </I></TT>&nbsp;
<BR>
<TT><I>unsigned char _code &nbsp;*uccp ; /* pointer to data
in R/O code space */</I></TT>&nbsp;
<BR>
<TT><I>unsigned char _idata *uccp; &nbsp;/* pointer to upper
128 bytes of ram */</I></TT>
<BR>

<BR>
All unqualified pointers are treated as 3-byte (4-byte for the ds390)
<I>generic</I> pointers. These type of pointers can also to be explicitly
declared.
<BR>

<BR>
<TT>unsigned char _generic *ucgp;</TT>
<BR>

<BR>
The highest order byte of the <I>generic</I> pointers contains the
data space information. Assembler support routines are called whenever
data is stored or retrieved using <I>generic</I> pointers. These are
useful for developing reusable library routines. Explicitly specifying
the pointer type will generate the most efficient code. Pointers declared
using a mixture of OLD and NEW style could have unpredictable results.

<P>

<H2><A NAME="SECTION00045000000000000000">
3.5 Parameters &amp; Local Variables</A>
</H2>

<P>
Automatic (local) variables and parameters to functions can either
be placed on the stack or in data-space. The default action of the
compiler is to place these variables in the internal RAM (for small
model) or external RAM (for Large model). This in fact makes them
<I>static</I> so by default functions are non-reentrant.

<P>
They can be placed on the stack either by using the <I>-stack-auto</I>
compiler option or by using the <I>reentrant</I> keyword in the function
declaration, e.g.:
<BR>

<BR>
<TT>unsigned char foo(char i) reentrant </TT>&nbsp;
<BR>
<TT>{ </TT>&nbsp;
<BR>
<TT>... </TT>&nbsp;
<BR>
<TT>}</TT>&nbsp;
<BR>

<BR>
Since stack space on 8051 is limited, the <I>reentrant</I> keyword
or the <I>-stack-auto</I> option should be used sparingly. Note that
the reentrant keyword just means that the parameters &amp; local variables
will be allocated to the stack, it <I>does not</I> mean that the function
is register bank independent.
<BR>

<BR>
Local variables can be assigned storage classes and absolute addresses,
e.g.: 
<BR>

<BR>
<TT>unsigned char foo() {</TT>&nbsp;
<BR>
<TT>&nbsp;&nbsp;&nbsp;&nbsp;xdata unsigned char i;</TT>&nbsp;
<BR>
<TT>&nbsp;&nbsp;&nbsp;&nbsp;bit bvar;</TT>&nbsp;
<BR>
<TT>&nbsp;&nbsp;&nbsp;&nbsp;data at 0x31 unsiged char j;</TT>&nbsp;
<BR>
<TT>&nbsp;&nbsp;&nbsp;&nbsp;... </TT>&nbsp;
<BR>
<TT>}</TT>&nbsp;
<BR>&nbsp;
<BR>
In the above example the variable <I>i</I> will be allocated in the
external ram, <I>bvar</I> in bit addressable space and <I>j</I> in
internal ram. When compiled with <I>-stack-auto</I> or when a function
is declared as <I>reentrant</I> this can only be done for static variables.

<P>
Parameters however are not allowed any storage class, (storage classes
for parameters will be ignored), their allocation is governed by the
memory model in use, and the reentrancy options.

<P>

<H2><A NAME="SECTION00046000000000000000">
3.6 Overlaying</A>
</H2>

<P>
For non-reentrant functions SDCC will try to reduce internal ram space
usage by overlaying parameters and local variables of a function (if
possible). Parameters and local variables of a function will be allocated
to an overlayable segment if the function has <I>no other function
calls and the function is non-reentrant and the memory model is small.</I>
If an explicit storage class is specified for a local variable, it
will NOT be overlayed.

<P>
Note that the compiler (not the linkage editor) makes the decision
for overlaying the data items. Functions that are called from an interrupt
service routine should be preceded by a #pragma&nbsp;NOOVERLAY if they
are not reentrant.

<P>
Also note that the compiler does not do any processing of inline assembler
code, so the compiler might incorrectly assign local variables and
parameters of a function into the overlay segment if the inline assembler
code calls other c-functions that might use the overlay. In that case
the #pragma&nbsp;NOOVERLAY should be used.

<P>
Parameters and Local variables of functions that contain 16 or 32
bit multiplication or division will NOT be overlayed since these are
implemented using external functions, e.g.:
<BR>

<BR>
<TT>#pragma SAVE </TT>&nbsp;
<BR>
<TT>#pragma NOOVERLAY </TT>&nbsp;
<BR>
<TT>void set_error(unsigned char errcd) </TT>&nbsp;
<BR>
<TT>{</TT>&nbsp;
<BR>
<TT>&nbsp;&nbsp;&nbsp;&nbsp;P3 = errcd;</TT>&nbsp;
<BR>
<TT>} </TT>&nbsp;
<BR>
<TT>#pragma RESTORE </TT>&nbsp;
<BR>&nbsp;
<BR>
<TT>void some_isr () interrupt 2 using 1 </TT>&nbsp;
<BR>
<TT>{</TT>&nbsp;
<BR>
<TT>&nbsp;&nbsp;&nbsp;&nbsp;...</TT>&nbsp;
<BR>
<TT>&nbsp;&nbsp;&nbsp;&nbsp;set_error(10);</TT>&nbsp;
<BR>
<TT>&nbsp;&nbsp;&nbsp;&nbsp;... </TT>&nbsp;
<BR>
<TT>}</TT>&nbsp;
<BR>&nbsp;
<BR>
In the above example the parameter <I>errcd</I> for the function <I>set_error</I>
would be assigned to the overlayable segment if the #pragma&nbsp;NOOVERLAY
was not present, this could cause unpredictable runtime behavior when
called from an ISR. The #pragma&nbsp;NOOVERLAY ensures that the parameters
and local variables for the function are NOT overlayed.

<P>

<H2><A NAME="SECTION00047000000000000000">
3.7 Interrupt Service Routines</A>
</H2>

<P>
SDCC allows interrupt service routines to be coded in C, with some
extended keywords.
<BR>

<BR>
<TT>void timer_isr (void) interrupt 2 using 1 </TT>&nbsp;
<BR>
<TT>{ </TT>&nbsp;
<BR>
<TT>.. </TT>&nbsp;
<BR>
<TT>}</TT>&nbsp;
<BR>&nbsp;
<BR>
The number following the <I>interrupt</I> keyword is the interrupt
number this routine will service. The compiler will insert a call
to this routine in the interrupt vector table for the interrupt number
specified. The <I>using</I> keyword is used to tell the compiler to
use the specified register bank (8051 specific) when generating code
for this function. Note that when some function is called from an
interrupt service routine it should be preceded by a #pragma&nbsp;NOOVERLAY
if it is not reentrant. A special note here, int (16 bit) and long
(32 bit) integer division, multiplication &amp; modulus operations are
implemented using external support routines developed in ANSI-C, if
an interrupt service routine needs to do any of these operations then
the support routines (as mentioned in a following section) will have
to be recompiled using the <I>-stack-auto</I> option and the source
file will need to be compiled using the <I>-int-long-ren</I>t compiler
option.

<P>
If you have multiple source files in your project, interrupt service
routines can be present in any of them, but a prototype of the isr
MUST be present or included in the file that contains the function
<I>main</I>.

<P>
Interrupt Numbers and the corresponding address &amp; descriptions for
the Standard 8051 are listed below. SDCC will automatically adjust
the interrupt vector table to the maximum interrupt number specified.
<BR>

<P>
 
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER">Interrupt #</TD>
<TD ALIGN="CENTER">Description</TD>
<TD ALIGN="CENTER">Vector Address</TD>
</TR>
<TR><TD ALIGN="CENTER">0</TD>
<TD ALIGN="CENTER">External 0</TD>
<TD ALIGN="CENTER">0x0003</TD>
</TR>
<TR><TD ALIGN="CENTER">1</TD>
<TD ALIGN="CENTER">Timer 0</TD>
<TD ALIGN="CENTER">0x000B</TD>
</TR>
<TR><TD ALIGN="CENTER">2</TD>
<TD ALIGN="CENTER">External 1</TD>
<TD ALIGN="CENTER">0x0013</TD>
</TR>
<TR><TD ALIGN="CENTER">3</TD>
<TD ALIGN="CENTER">Timer 1</TD>
<TD ALIGN="CENTER">0x001B</TD>
</TR>
<TR><TD ALIGN="CENTER">4</TD>
<TD ALIGN="CENTER">Serial</TD>
<TD ALIGN="CENTER">0x0023</TD>
</TR>
</TABLE>
<BR>

<BR>
If the interrupt service routine is defined without <I>using</I> a
register bank or with register bank 0 (using 0), the compiler will
save the registers used by itself on the stack upon entry and restore
them at exit, however if such an interrupt service routine calls another
function then the entire register bank will be saved on the stack.
This scheme may be advantageous for small interrupt service routines
which have low register usage.

<P>
If the interrupt service routine is defined to be using a specific
register bank then only <I>a, b &amp; dptr</I> are save and restored,
if such an interrupt service routine calls another function (using
another register bank) then the entire register bank of the called
function will be saved on the stack. This scheme is recommended for
larger interrupt service routines.

<P>
Calling other functions from an interrupt service routine is not recommended,
avoid it if possible.
<BR>

<BR>
Also see the _naked modifier.

<P>

<H2><A NAME="SECTION00048000000000000000">
3.8 Critical Functions</A>
</H2>

<P>
A special keyword may be associated with a function declaring it as
<I>critical</I>. SDCC will generate code to disable all interrupts
upon entry to a critical function and enable them back before returning.
Note that nesting critical functions may cause unpredictable results.
<BR>

<BR>
<TT>int foo () critical </TT>&nbsp;
<BR>
<TT>{ </TT>&nbsp;
<BR>
<TT>... </TT>&nbsp;
<BR>
<TT>... </TT>&nbsp;
<BR>
<TT>}</TT>&nbsp;
<BR>

<BR>
The critical attribute maybe used with other attributes like <I>reentrant.</I>

<P>

<H2><A NAME="SECTION00049000000000000000">
3.9 Naked Functions</A>
</H2>

<P>
A special keyword may be associated with a function declaring it as
<I>_naked.</I> The <I>_naked</I> function modifier attribute prevents
the compiler from generating prologue and epilogue code for that function.
This means that the user is entirely responsible for such things as
saving any registers that may need to be preserved, selecting the
proper register bank, generating the <I>return</I> instruction at
the end, etc. Practically, this means that the contents of the function
must be written in inline assembler. This is particularly useful for
interrupt functions, which can have a large (and often unnecessary)
prologue/epilogue. For example, compare the code generated by these
two functions:
<BR>

<BR>
<TT>data unsigned char counter;</TT>&nbsp;
<BR>
<TT>void simpleInterrupt(void) interrupt 1</TT>&nbsp;
<BR>
<TT>{</TT>&nbsp;
<BR>
<TT>&nbsp;&nbsp;&nbsp;&nbsp;counter++;</TT>&nbsp;
<BR>
<TT>}</TT>&nbsp;
<BR>&nbsp;
<BR>
<TT>void nakedInterrupt(void) interrupt 2 _naked</TT>&nbsp;
<BR>
<TT>{</TT>&nbsp;
<BR>
<TT>&nbsp;&nbsp;&nbsp;&nbsp;_asm</TT>&nbsp;
<BR>
<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_counter</TT>&nbsp;
<BR>
<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reti&nbsp;&nbsp;&nbsp;&nbsp;; MUST explicitly include ret in _naked
function.</TT>&nbsp;
<BR>
<TT>&nbsp;&nbsp;&nbsp;&nbsp;_endasm;</TT>&nbsp;
<BR>
<TT>}</TT>
<BR>

<BR>
For an 8051 target, the generated simpleInterrupt looks like:
<BR>

<BR>
<TT>_simpleIterrupt:</TT>&nbsp;
<BR>
<TT>&nbsp;&nbsp;&nbsp;&nbsp;push&nbsp;&nbsp;&nbsp;&nbsp;acc</TT>&nbsp;
<BR>
<TT>&nbsp;&nbsp;&nbsp;&nbsp;push&nbsp;&nbsp;&nbsp;&nbsp;b</TT>&nbsp;
<BR>
<TT>&nbsp;&nbsp;&nbsp;&nbsp;push&nbsp;&nbsp;&nbsp;&nbsp;dpl</TT>&nbsp;
<BR>
<TT>&nbsp;&nbsp;&nbsp;&nbsp;push&nbsp;&nbsp;&nbsp;&nbsp;dph</TT>&nbsp;
<BR>
<TT>&nbsp;&nbsp;&nbsp;&nbsp;push&nbsp;&nbsp;&nbsp;&nbsp;psw</TT>&nbsp;
<BR>
<TT>&nbsp;&nbsp;&nbsp;&nbsp;mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;psw,#0x00</TT>&nbsp;
<BR>
<TT>&nbsp;&nbsp;&nbsp;&nbsp;inc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_counter</TT>&nbsp;
<BR>
<TT>&nbsp;&nbsp;&nbsp;&nbsp;pop&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;psw</TT>&nbsp;
<BR>
<TT>&nbsp;&nbsp;&nbsp;&nbsp;pop&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dph</TT>&nbsp;
<BR>
<TT>&nbsp;&nbsp;&nbsp;&nbsp;pop&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dpl</TT>&nbsp;
<BR>
<TT>&nbsp;&nbsp;&nbsp;&nbsp;pop&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b</TT>&nbsp;
<BR>
<TT>&nbsp;&nbsp;&nbsp;&nbsp;pop&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;acc</TT>&nbsp;
<BR>
<TT>&nbsp;&nbsp;&nbsp;&nbsp;reti</TT>
<BR>

<BR>
whereas nakedInterrupt looks like:
<BR>

<BR>
<TT>_nakedInterrupt:</TT>&nbsp;
<BR>
<TT>&nbsp;&nbsp;&nbsp;&nbsp;inc&nbsp;&nbsp;&nbsp;&nbsp;_counter</TT>&nbsp;
<BR>
<TT>&nbsp;&nbsp;&nbsp;&nbsp;reti&nbsp;&nbsp;&nbsp;; MUST explicitly include ret(i) in _naked
function.</TT>
<BR>

<BR>
While there is nothing preventing you from writing C code inside a
_naked function, there are many ways to shoot yourself in the foot
doing this, and is is recommended that you stick to inline assembler.

<P>

<H2><A NAME="SECTION000410000000000000000">
3.10 Functions using private banks</A>
</H2>

<P>
The <I>using</I> attribute (which tells the compiler to use a register
bank other than the default bank zero) should only be applied to <I>interrupt</I>
functions (see note 1 below). This will in most circumstances make
the generated ISR code more efficient since it will not have to save
registers on the stack.

<P>
The <I>using</I> attribute will have no effect on the generated code
for a <I>non-interrupt</I> function (but may occasionally be useful
anyway<A NAME="tex2html1"
 HREF="#foot530"><SUP>1</SUP></A>).
<BR>
<I>(pending: I don't think this has been done yet)</I>

<P>
An <I>interrupt</I> function using a non-zero bank will assume that
it can trash that register bank, and will not save it. Since high-priority
interrupts can interrupt low-priority ones on the 8051 and friends,
this means that if a high-priority ISR <I>using</I> a particular bank
occurs while processing a low-priority ISR <I>using</I> the same bank,
terrible and bad things can happen. To prevent this, no single register
bank should be <I>used</I> by both a high priority and a low priority
ISR. This is probably most easily done by having all high priority
ISRs use one bank and all low priority ISRs use another. If you have
an ISR which can change priority at runtime, you're on your own: I
suggest using the default bank zero and taking the small performance
hit.

<P>
It is most efficient if your ISR calls no other functions. If your
ISR must call other functions, it is most efficient if those functions
use the same bank as the ISR (see note 1 below); the next best is
if the called functions use bank zero. It is very inefficient to call
a function using a different, non-zero bank from an ISR. 

<P>

<H2><A NAME="SECTION000411000000000000000">
3.11 Absolute Addressing</A>
</H2>

<P>
Data items can be assigned an absolute address with the <I>at &lt;address&gt;</I>
keyword, in addition to a storage class, e.g.:
<BR>

<BR>
<TT>xdata at 0x8000 unsigned char PORTA_8255 ;</TT>&nbsp;
<BR>

<BR>
In the above example the PORTA_8255 will be allocated to the location
0x8000 of the external ram. Note that this feature is provided to
give the programmer access to <I>memory mapped</I> devices attached
to the controller. The compiler does not actually reserve any space
for variables declared in this way (they are implemented with an equate
in the assembler). Thus it is left to the programmer to make sure
there are no overlaps with other variables that are declared without
the absolute address. The assembler listing file (.lst) and the linker
output files (.rst) and (.map) are a good places to look for such
overlaps.
<BR>

<BR>
Absolute address can be specified for variables in all storage classes,
e.g.:
<BR>

<BR>
<TT>bit at 0x02 bvar;</TT>&nbsp;
<BR>&nbsp;
<BR>
The above example will allocate the variable at offset 0x02 in the
bit-addressable space. There is no real advantage to assigning absolute
addresses to variables in this manner, unless you want strict control
over all the variables allocated.

<P>

<H2><A NAME="SECTION000412000000000000000">
3.12 Startup Code</A>
</H2>

<P>
The compiler inserts a call to the C routine <I>_sdcc__external__startup()</I>
at the start of the CODE area. This routine is in the runtime library.
By default this routine returns 0, if this routine returns a non-zero
value, the static &amp; global variable initialization will be skipped
and the function main will be invoked Other wise static &amp; global
variables will be initialized before the function main is invoked.
You could add a <I>_sdcc__external__startup()</I> routine to
your program to override the default if you need to setup hardware
or perform some other critical operation prior to static &amp; global
variable initialization.

<P>

<H2><A NAME="SECTION000413000000000000000">
3.13 Inline Assembler Code</A>
</H2>

<P>
SDCC allows the use of in-line assembler with a few restriction as
regards labels. All labels defined within inline assembler code <I>has
to be</I> of the form <I>nnnnn$</I> where nnnn is a number less than
100 (which implies a limit of utmost 100 inline assembler labels <I>per
function</I>). It is strongly recommended that each assembly
instruction (including labels) be placed in a separate line (as the
example shows). When the <I>-peep-asm</I> command line option is
used, the inline assembler code will be passed through the peephole
optimizer. This might cause some unexpected changes in the inline
assembler code. Please go throught the peephole optimizer rules defined
in file <I>SDCCpeeph.def</I> carefully before using this option.
<BR>

<BR>
<TT>_asm </TT>&nbsp;
<BR>
<TT>&nbsp;&nbsp;&nbsp;&nbsp;mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b,#10 </TT>&nbsp;
<BR>
<TT>00001$: </TT>&nbsp;
<BR>
<TT>&nbsp;&nbsp;&nbsp;&nbsp;djnz&nbsp;&nbsp;&nbsp;&nbsp;b,00001$ </TT>&nbsp;
<BR>
<TT>_endasm ;</TT>
<BR>

<BR>
The inline assembler code can contain any valid code understood by
the assembler, this includes any assembler directives and comment
lines. The compiler does not do any validation of the code within
the <TT>_asm ... _endasm;</TT> keyword pair. 
<BR>

<BR>
Inline assembler code cannot reference any C-Labels, however it can
reference labels defined by the inline assembler, e.g.:
<BR>

<BR>
<TT>foo() { </TT>&nbsp;
<BR>
<TT>&nbsp;&nbsp;&nbsp;&nbsp;/* some c code */ </TT>&nbsp;
<BR>
<TT>&nbsp;&nbsp;&nbsp;&nbsp;_asm </TT>&nbsp;
<BR>
<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; some assembler code </TT>&nbsp;
<BR>
<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ljmp $0003 </TT>&nbsp;
<BR>
<TT>&nbsp;&nbsp;&nbsp;&nbsp;_endasm; </TT>&nbsp;
<BR>
<TT>&nbsp;&nbsp;&nbsp;&nbsp;/* some more c code */ </TT>&nbsp;
<BR>
<TT>clabel:&nbsp;&nbsp;/* inline assembler cannot reference this label
*/ </TT>&nbsp;
<BR>
<TT>&nbsp;&nbsp;&nbsp;&nbsp;_asm</TT>&nbsp;
<BR>
<TT>&nbsp;&nbsp;&nbsp;&nbsp;$0003: ;label (can be reference by inline assembler
only) </TT>&nbsp;
<BR>
<TT>&nbsp;&nbsp;&nbsp;&nbsp;_endasm ; </TT>&nbsp;
<BR>
<TT>&nbsp;&nbsp;&nbsp;&nbsp;/* some more c code */</TT>&nbsp;
<BR>
<TT>}</TT>&nbsp;
<BR>&nbsp;
<BR>
In other words inline assembly code can access labels defined in inline
assembly within the scope of the funtion. 

<P>
The same goes the other way, ie. labels defines in inline assembly
CANNOT be accessed by C statements.

<P>

<H2><A NAME="SECTION000414000000000000000">
3.14 int(16 bit) and long (32 bit) Support</A>
</H2>

<P>
For signed &amp; unsigned int (16 bit) and long (32 bit) variables, division,
multiplication and modulus operations are implemented by support routines.
These support routines are all developed in ANSI-C to facilitate porting
to other MCUs, although some model specific assembler optimations
are used. The following files contain the described routine, all of
them can be found in &lt;installdir&gt;/share/sdcc/lib.
<BR>

<BR>
<I>&lt;pending: tabularise this&gt;</I>
<BR>

<BR>
_mulsint.c - signed 16 bit multiplication (calls _muluint)
<BR>
_muluint.c - unsigned 16 bit multiplication
<BR>
_divsint.c - signed 16 bit division (calls _divuint)
<BR>
_divuint.c - unsigned 16 bit division
<BR>
_modsint.c - signed 16 bit modulus (call _moduint)
<BR>
_moduint.c - unsigned 16 bit modulus
<BR>
_mulslong.c - signed 32 bit multiplication (calls _mululong)
<BR>
_mululong.c - unsigned32 bit multiplication
<BR>
_divslong.c - signed 32 division (calls _divulong)
<BR>
_divulong.c - unsigned 32 division
<BR>
_modslong.c - signed 32 bit modulus (calls _modulong)
<BR>
_modulong.c - unsigned 32 bit modulus 
<BR>

<BR>
Since they are compiled as <I>non-reentrant</I>, interrupt service
routines should not do any of the above operations. If this is unavoidable
then the above routines will need to be compiled with the <I>-stack-auto</I>
option, after which the source program will have to be compiled with
<I>-int-long-rent</I> option.

<P>

<H2><A NAME="SECTION000415000000000000000">
3.15 Floating Point Support</A>
</H2>

<P>
SDCC supports IEEE (single precision 4bytes) floating point numbers.The
floating point support routines are derived from gcc's floatlib.c
and consists of the following routines:
<BR>

<BR>
<I>&lt;pending: tabularise this&gt;</I>
<BR>

<BR>
_fsadd.c - add floating point numbers
<BR>
_fssub.c - subtract floating point numbers
<BR>
_fsdiv.c - divide floating point numbers
<BR>
_fsmul.c - multiply floating point numbers
<BR>
_fs2uchar.c - convert floating point to unsigned char
<BR>
_fs2char.c - convert floating point to signed char
<BR>
_fs2uint.c - convert floating point to unsigned int
<BR>
_fs2int.c - convert floating point to signed int
<BR>
_fs2ulong.c - convert floating point to unsigned long
<BR>
_fs2long.c - convert floating point to signed long
<BR>
_uchar2fs.c - convert unsigned char to floating point
<BR>
_char2fs.c - convert char to floating point number
<BR>
_uint2fs.c - convert unsigned int to floating point
<BR>
_int2fs.c - convert int to floating point numbers
<BR>
_ulong2fs.c - convert unsigned long to floating point number
<BR>
_long2fs.c - convert long to floating point number
<BR>

<BR>
Note if all these routines are used simultaneously the data space
might overflow. For serious floating point usage it is strongly recommended
that the large model be used.

<P>

<H2><A NAME="SECTION000416000000000000000">
3.16 MCS51 Memory Models</A>
</H2>

<P>
SDCC allows two memory models for MCS51 code, small and large. Modules
compiled with different memory models should <I>never</I> be combined
together or the results would be unpredictable. The library routines
supplied with the compiler are compiled as both small and large. The
compiled library modules are contained in seperate directories as
small and large so that you can link to either set. 

<P>
When the large model is used all variables declared without a storage
class will be allocated into the external ram, this includes all parameters
and local variables (for non-reentrant functions). When the small
model is used variables without storage class are allocated in the
internal ram.

<P>
Judicious usage of the processor specific storage classes and the
'reentrant' function type will yield much more efficient code, than
using the large model. Several optimizations are disabled when the
program is compiled using the large model, it is therefore strongly
recommdended that the small model be used unless absolutely required.

<P>

<H2><A NAME="SECTION000417000000000000000">
3.17 DS390 Memory Models</A>
</H2>

<P>
The only model supported is Flat 24. This generates code for the 24
bit contiguous addressing mode of the Dallas DS80C390 part. In this
mode, up to four meg of external RAM or code space can be directly
addressed. See the data sheets at www.dalsemi.com for further information
on this part.
<BR>

<BR>
In older versions of the compiler, this option was used with the MCS51
code generator (<I>-mmcs51</I>). Now, however, the '390 has it's own
code generator, selected by the <I>-mds390</I> switch. 
<BR>

<BR>
Note that the compiler does not generate any code to place the processor
into 24 bitmode (although <I>tinibios</I> in the ds390 libraries will
do that for you). If you don't use <I>tinibios</I>, the boot loader
or similar code must ensure that the processor is in 24 bit contiguous
addressing mode before calling the SDCC startup code.
<BR>

<BR>
Like the <I>-model-large</I> option, variables will by default be
placed into the XDATA segment. 
<BR>

<BR>
Segments may be placed anywhere in the 4 meg address space using the
usual -*-loc options. Note that if any segments are located above
64K, the -r flag must be passed to the linker to generate the proper
segment relocations, and the Intel HEX output format must be used.
The -r flag can be passed to the linker by using the option <I>-Wl-r</I>
on the sdcc command line. However, currently the linker can not handle
code segments &gt; 64k.

<P>

<H2><A NAME="SECTION000418000000000000000">
3.18 Defines Created by the Compiler</A>
</H2>

<P>
The compiler creates the following #defines.

<P>

<UL>
<LI>SDCC - this Symbol is always defined.</LI>
<LI>SDCC_mcs51 or SDCC_ds390 or SDCC_z80, etc - depending on the model
used (e.g.: -mds390)</LI>
<LI>__mcs51 or __ds390 or __z80, etc - depending on the model used
(e.g. -mz80)</LI>
<LI>SDCC_STACK_AUTO - this symbol is defined when <I>-stack-auto</I>
option is used.</LI>
<LI>SDCC_MODEL_SMALL - when <I>-model-small</I> is used.</LI>
<LI>SDCC_MODEL_LARGE - when <I>-model-large</I> is used.</LI>
<LI>SDCC_USE_XSTACK - when <I>-xstack</I> option is used.</LI>
<LI>SDCC_STACK_TENBIT - when <I>-mds390</I> is used</LI>
<LI>SDCC_MODEL_FLAT24 - when <I>-mds390</I> is used</LI>
</UL>

<P>

<H1><A NAME="SECTION00050000000000000000">
4. SDCC Technical Data</A>
</H1>

<P>

<H2><A NAME="SECTION00051000000000000000">
4.1 Optimizations</A>
</H2>

<P>
SDCC performs a host of standard optimizations in addition to some
MCU specific optimizations. 

<P>

<H3><A NAME="SECTION00051100000000000000">
4.1.1 Sub-expression Elimination</A>
</H3>

<P>
The compiler does local and global common subexpression elimination,
e.g.: 
<BR>

<BR>
<TT>i = x + y + 1; </TT>&nbsp;
<BR>
<TT>j = x + y;</TT>
<BR>

<BR>
will be translated to
<BR>

<BR>
<TT>iTemp = x + y </TT>&nbsp;
<BR>
<TT>i = iTemp + 1 </TT>&nbsp;
<BR>
<TT>j = iTemp</TT>&nbsp;
<BR>

<BR>
Some subexpressions are not as obvious as the above example, e.g.:
<BR>

<BR>
<TT>a-&gt;b[i].c = 10; </TT>&nbsp;
<BR>
<TT>a-&gt;b[i].d = 11;</TT>
<BR>

<BR>
In this case the address arithmetic a-&gt;b[i] will be computed only
once; the equivalent code in C would be.
<BR>

<BR>
<TT>iTemp = a-&gt;b[i]; </TT>&nbsp;
<BR>
<TT>iTemp.c = 10; </TT>&nbsp;
<BR>
<TT>iTemp.d = 11;</TT>
<BR>

<BR>
The compiler will try to keep these temporary variables in registers.

<P>

<H3><A NAME="SECTION00051200000000000000">
4.1.2 Dead-Code Elimination</A>
</H3>

<P>
 
<TT>int global; </TT>&nbsp;
<BR>
<TT>void f () { </TT>&nbsp;
<BR>
<TT>&nbsp;&nbsp;int i; </TT>&nbsp;
<BR>
<TT>&nbsp;&nbsp;i = 1; &nbsp;/* dead store */ </TT>&nbsp;
<BR>
<TT>&nbsp;&nbsp;global = 1;&nbsp;/* dead store */ </TT>&nbsp;
<BR>
<TT>&nbsp;&nbsp;global = 2; </TT>&nbsp;
<BR>
<TT>&nbsp;&nbsp;return; </TT>&nbsp;
<BR>
<TT>&nbsp;&nbsp;global = 3;&nbsp;/* unreachable */ </TT>&nbsp;
<BR>
<TT>}</TT>
<BR>

<BR>
will be changed to
<BR>

<BR>
<TT>int global; void f () </TT>&nbsp;
<BR>
<TT>{</TT>&nbsp;
<BR>
<TT>&nbsp;&nbsp;global = 2; </TT>&nbsp;
<BR>
<TT>&nbsp;&nbsp;return; </TT>&nbsp;
<BR>
<TT>}</TT>

<P>

<H3><A NAME="SECTION00051300000000000000">
4.1.3 Copy-Propagation</A>
</H3>

<P>
 
<TT>int f() { </TT>&nbsp;
<BR>
<TT>&nbsp;&nbsp;int i, j; </TT>&nbsp;
<BR>
<TT>&nbsp;&nbsp;i = 10; </TT>&nbsp;
<BR>
<TT>&nbsp;&nbsp;j = i; </TT>&nbsp;
<BR>
<TT>&nbsp;&nbsp;return j; </TT>&nbsp;
<BR>
<TT>}</TT>
<BR>

<BR>
will be changed to 
<BR>

<BR>
<TT>int f() { </TT>&nbsp;
<BR>
<TT>&nbsp; &nbsp; int i,j; </TT>&nbsp;
<BR>
<TT>&nbsp; &nbsp; i = 10; </TT>&nbsp;
<BR>
<TT>&nbsp; &nbsp; j = 10; </TT>&nbsp;
<BR>
<TT>&nbsp; &nbsp; return 10; </TT>&nbsp;
<BR>
<TT>}</TT>&nbsp;
<BR>&nbsp;
<BR>
Note: the dead stores created by this copy propagation will be eliminated
by dead-code elimination.

<P>

<H3><A NAME="SECTION00051400000000000000">
4.1.4 Loop Optimizations</A>
</H3>

<P>
Two types of loop optimizations are done by SDCC loop invariant lifting
and strength reduction of loop induction variables. In addition to
the strength reduction the optimizer marks the induction variables
and the register allocator tries to keep the induction variables in
registers for the duration of the loop. Because of this preference
of the register allocator, loop induction optimization causes an increase
in register pressure, which may cause unwanted spilling of other temporary
variables into the stack / data space. The compiler will generate
a warning message when it is forced to allocate extra space either
on the stack or data space. If this extra space allocation is undesirable
then induction optimization can be eliminated either for the entire
source file (with -noinduction option) or for a given function only
using #pragma&nbsp;NOINDUCTION.
<BR>

<BR>
Loop Invariant:
<BR>

<BR>
<TT>for (i = 0 ; i &lt; 100 ; i ++) </TT>&nbsp;
<BR>
 <TT>&nbsp; &nbsp;f += k + l;</TT>
<BR>

<BR>
changed to
<BR>

<BR>
<TT>itemp = k + l; </TT>&nbsp;
<BR>
<TT>for (i = 0; i &lt; 100; i++) </TT>&nbsp;
<BR>
<TT>&nbsp;&nbsp;f += itemp;</TT>
<BR>

<BR>
As mentioned previously some loop invariants are not as apparent,
all static address computations are also moved out of the loop.
<BR>

<BR>
Strength Reduction, this optimization substitutes an expression by
a cheaper expression:
<BR>

<BR>
<TT>for (i=0;i &lt; 100; i++)</TT>&nbsp;
<BR>
<TT>&nbsp;&nbsp;ar[i*5] = i*3;</TT>
<BR>

<BR>
changed to
<BR>

<BR>
<TT>itemp1 = 0; </TT>&nbsp;
<BR>
<TT>itemp2 = 0; </TT>&nbsp;
<BR>
<TT>for (i=0;i&lt; 100;i++) { </TT>&nbsp;
<BR>
 <TT>&nbsp; &nbsp;ar[itemp1] = itemp2; </TT>&nbsp;
<BR>
 <TT>&nbsp; &nbsp;itemp1 += 5; </TT>&nbsp;
<BR>
 <TT>&nbsp; &nbsp;itemp2 += 3; </TT>&nbsp;
<BR>
<TT>}</TT>
<BR>

<BR>
The more expensive multiplication is changed to a less expensive addition.

<P>

<H3><A NAME="SECTION00051500000000000000">
4.1.5 Loop Reversing</A>
</H3>

<P>
This optimization is done to reduce the overhead of checking loop
boundaries for every iteration. Some simple loops can be reversed
and implemented using a ``decrement and jump if not zero'' instruction.
SDCC checks for the following criterion to determine if a loop is
reversible (note: more sophisticated compilers use data-dependency
analysis to make this determination, SDCC uses a more simple minded
analysis).

<P>

<UL>
<LI>The 'for' loop is of the form 
<BR>

<BR>
<TT>for (&lt;symbol&gt; = &lt;expression&gt; ; &lt;sym&gt; [&lt; | &lt;=] &lt;expression&gt;
; [&lt;sym&gt;++ | &lt;sym&gt; += 1])</TT>&nbsp;
<BR>
<TT>&nbsp;&nbsp;&nbsp;&nbsp;&lt;for body&gt;</TT></LI>
<LI>The &lt;for body&gt; does not contain ``continue'' or 'break''.</LI>
<LI>All goto's are contained within the loop.</LI>
<LI>No function calls within the loop.</LI>
<LI>The loop control variable &lt;sym&gt; is not assigned any value within the
loop</LI>
<LI>The loop control variable does NOT participate in any arithmetic operation
within the loop.</LI>
<LI>There are NO switch statements in the loop.</LI>
</UL>
Note djnz instruction can be used for 8-bit values <I>only</I>, therefore
it is advantageous to declare loop control symbols as <I>char</I>.
Ofcourse this may not be possible on all situations.

<P>

<H3><A NAME="SECTION00051600000000000000">
4.1.6 Algebraic Simplifications</A>
</H3>

<P>
SDCC does numerous algebraic simplifications, the following is a small
sub-set of these optimizations.
<BR>

<BR>
<TT>i = j + 0 ; /* changed to */ i = j; </TT>&nbsp;
<BR>
<TT>i /= 2; /* changed to */ i &gt;&gt;= 1; </TT>&nbsp;
<BR>
<TT>i = j - j ; /* changed to */ i = 0; </TT>&nbsp;
<BR>
<TT>i = j / 1 ; /* changed to */ i = j;</TT>
<BR>

<BR>
Note the subexpressions given above are generally introduced by macro
expansions or as a result of copy/constant propagation.

<P>

<H3><A NAME="SECTION00051700000000000000">
4.1.7 'switch' Statements</A>
</H3>

<P>
SDCC changes switch statements to jump tables when the following conditions
are true. 

<P>

<UL>
<LI>The case labels are in numerical sequence, the labels need not be
in order, and the starting number need not be one or zero.
<BR>

<BR>
<TT>switch(i) {&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;switch (i)
{ </TT>&nbsp;
<BR>
<TT>case 4:... &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;case 1: ... </TT>&nbsp;
<BR>
<TT>case 5:... &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;case 2: ... </TT>&nbsp;
<BR>
<TT>case 3:... &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;case 3: ... </TT>&nbsp;
<BR>
<TT>case 6:... &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;case 4: ... </TT>&nbsp;
<BR>
<TT>}&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}</TT>&nbsp;
<BR>&nbsp;
<BR>
Both the above switch statements will be implemented using a jump-table.</LI>
<LI>The number of case labels is at least three, since it takes two conditional
statements to handle the boundary conditions.</LI>
<LI>The number of case labels is less than 84, since each label takes
3 bytes and a jump-table can be utmost 256 bytes long. </LI>
</UL>
Switch statements which have gaps in the numeric sequence or those
that have more that 84 case labels can be split into more than one
switch statement for efficient code generation, e.g.:
<BR>

<BR>
<TT>switch (i) { </TT>&nbsp;
<BR>
<TT>case 1: ... </TT>&nbsp;
<BR>
<TT>case 2: ... </TT>&nbsp;
<BR>
<TT>case 3: ... </TT>&nbsp;
<BR>
<TT>case 4: ... </TT>&nbsp;
<BR>
<TT>case 9: ... </TT>&nbsp;
<BR>
<TT>case 10: ... </TT>&nbsp;
<BR>
<TT>case 11: ... </TT>&nbsp;
<BR>
<TT>case 12: ... </TT>&nbsp;
<BR>
<TT>}</TT>
<BR>

<BR>
If the above switch statement is broken down into two switch statements
<BR>

<BR>
<TT>switch (i) { </TT>&nbsp;
<BR>
<TT>case 1: ... </TT>&nbsp;
<BR>
<TT>case 2: ... </TT>&nbsp;
<BR>
<TT>case 3: ... </TT>&nbsp;
<BR>
<TT>case 4: ... </TT>&nbsp;
<BR>
<TT>}</TT>&nbsp;
<BR>&nbsp;
<BR>
and&nbsp;
<BR>&nbsp;
<BR>
<TT>switch (i) { </TT>&nbsp;
<BR>
<TT>case 9: &nbsp;... </TT>&nbsp;
<BR>
<TT>case 10: ... </TT>&nbsp;
<BR>
<TT>case 11: ... </TT>&nbsp;
<BR>
<TT>case 12:&nbsp;... </TT>&nbsp;
<BR>
<TT>}</TT>&nbsp;
<BR>&nbsp;
<BR>
then both the switch statements will be implemented using jump-tables
whereas the unmodified switch statement will not be.

<P>

<H3><A NAME="SECTION00051800000000000000">
4.1.8 Bit-shifting Operations.</A>
</H3>

<P>
Bit shifting is one of the most frequently used operation in embedded
programming. SDCC tries to implement bit-shift operations in the most
efficient way possible, e.g.:
<BR>&nbsp;
<BR>
<TT>unsigned char i;</TT>&nbsp;
<BR>
<TT>... </TT>&nbsp;
<BR>
<TT>i&gt;&gt;= 4; </TT>&nbsp;
<BR>
<TT>...</TT>&nbsp;
<BR>

<BR>
generates the following code:
<BR>&nbsp;
<BR>
<TT>mov a,_i </TT>&nbsp;
<BR>
<TT>swap a </TT>&nbsp;
<BR>
<TT>anl a,#0x0f </TT>&nbsp;
<BR>
<TT>mov _i,a</TT>
<BR>

<BR>
In general SDCC will never setup a loop if the shift count is known.
Another example:
<BR>

<BR>
<TT>unsigned int i; </TT>&nbsp;
<BR>
<TT>... </TT>&nbsp;
<BR>
<TT>i &gt;&gt;= 9; </TT>&nbsp;
<BR>
<TT>...</TT>
<BR>

<BR>
will generate:
<BR>

<BR>
<TT>mov a,(_i + 1) </TT>&nbsp;
<BR>
<TT>mov (_i + 1),#0x00 </TT>&nbsp;
<BR>
<TT>clr c </TT>&nbsp;
<BR>
<TT>rrc a </TT>&nbsp;
<BR>
<TT>mov _i,a</TT>
<BR>

<BR>
Note that SDCC stores numbers in little-endian format (i.e. lowest
order first).

<P>

<H3><A NAME="SECTION00051900000000000000">
4.1.9 Bit-rotation</A>
</H3>

<P>
A special case of the bit-shift operation is bit rotation, SDCC recognizes
the following expression to be a left bit-rotation:
<BR>

<BR>
<TT>unsigned char i; </TT>&nbsp;
<BR>
<TT>... </TT>&nbsp;
<BR>
<TT>i = ((i &lt;&lt; 1) | (i &gt;&gt;
7));</TT> 
<BR>
...
<BR>

<BR>
will generate the following code:
<BR>

<BR>
<TT>mov a,_i </TT>&nbsp;
<BR>
<TT>rl a </TT>&nbsp;
<BR>
<TT>mov _i,a</TT>
<BR>

<BR>
SDCC uses pattern matching on the parse tree to determine this operation.Variations
of this case will also be recognized as bit-rotation, i.e.: 
<BR>

<BR>
<TT>i = ((i &gt;&gt; 7) | (i &lt;&lt;
1)); /* left-bit rotation */</TT>

<P>

<H3><A NAME="SECTION000511000000000000000">
4.1.10 Highest Order Bit</A>
</H3>

<P>
It is frequently required to obtain the highest order bit of an integral
type (long, int, short or char types). SDCC recognizes the following
expression to yield the highest order bit and generates optimized
code for it, e.g.:
<BR>

<BR>
 <TT>unsigned int gint; </TT>&nbsp;
<BR>&nbsp;
<BR>
<TT>foo () { </TT>&nbsp;
<BR>
<TT>unsigned char hob; </TT>&nbsp;
<BR>
<TT>&nbsp;&nbsp;... </TT>&nbsp;
<BR>
<TT>&nbsp;&nbsp;hob = (gint &gt;&gt; 15) &amp; 1; </TT>&nbsp;
<BR>
<TT>&nbsp;&nbsp;.. </TT>&nbsp;
<BR>
<TT>}</TT>
<BR>

<BR>
will generate the following code:
<BR>&nbsp;
<BR>
<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 61
;&nbsp; hob.c 7 </TT>&nbsp;
<BR>
<TT>&nbsp;&nbsp; 000A E5*01&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 62&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
mov&nbsp; a,(_gint + 1) </TT>&nbsp;
<BR>
<TT>&nbsp;&nbsp; 000C 33&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 63&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
rlc&nbsp; a </TT>&nbsp;
<BR>
<TT>&nbsp;&nbsp; 000D E4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 64&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
clr&nbsp; a </TT>&nbsp;
<BR>
<TT>&nbsp;&nbsp; 000E 13&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 65&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
rrc&nbsp; a </TT>&nbsp;
<BR>
<TT>&nbsp;&nbsp; 000F F5*02&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 66&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
mov&nbsp; _foo_hob_1_1,a</TT>&nbsp;
<BR>&nbsp;
<BR>
Variations of this case however will <I>not</I> be recognized. It
is a standard C expression, so I heartily recommend this be the only
way to get the highest order bit, (it is portable). Of course it will
be recognized even if it is embedded in other expressions, e.g.:
<BR>

<BR>
<TT>xyz = gint + ((gint &gt;&gt; 15) &amp; 1);</TT>
<BR>

<BR>
will still be recognized.

<P>

<H3><A NAME="SECTION000511100000000000000">
4.1.11 Peep-hole Optimizer</A>
</H3>

<P>
The compiler uses a rule based, pattern matching and re-writing mechanism
for peep-hole optimization. It is inspired by <I>copt</I> a peep-hole
optimizer by Christopher W. Fraser (cwfraser@microsoft.com). A default
set of rules are compiled into the compiler, additional rules may
be added with the <I>-peep-file &lt;filename&gt;</I> option. The rule language
is best illustrated with examples.
<BR>

<BR>
<TT>replace { </TT>&nbsp;
<BR>
<TT>&nbsp;&nbsp;mov %1,a </TT>&nbsp;
<BR>
<TT>&nbsp;&nbsp;mov a,%1</TT>&nbsp;
<BR>
<TT>} by {</TT>&nbsp;
<BR>
<TT>&nbsp;&nbsp;mov %1,a</TT>&nbsp;
<BR>
<TT>}</TT>
<BR>

<BR>
The above rule will change the following assembly sequence:
<BR>

<BR>
<TT>&nbsp;&nbsp;mov r1,a </TT>&nbsp;
<BR>
<TT>&nbsp;&nbsp;mov a,r1</TT>
<BR>

<BR>
to
<BR>

<BR>
<TT>mov r1,a</TT>
<BR>

<BR>
Note: All occurrences of a <I>%n</I> (pattern variable) must denote
the same string. With the above rule, the assembly sequence:
<BR>

<BR>
<TT>&nbsp;&nbsp;mov r1,a </TT>&nbsp;
<BR>
<TT>&nbsp;&nbsp;mov a,r2</TT>
<BR>

<BR>
will remain unmodified.
<BR>

<BR>
Other special case optimizations may be added by the user (via <I>-peep-file
option</I>). E.g. some variants of the 8051 MCU allow only <TT>ajmp</TT>
and <TT>acall</TT>. The following two rules will change all <TT>ljmp</TT>
and <TT>lcall</TT> to <TT>ajmp</TT> and <TT>acall</TT>
<BR>

<BR>
<TT>replace { lcall %1 } by { acall %1 } </TT>&nbsp;
<BR>
<TT>replace { ljmp %1 } by { ajmp %1 }</TT>
<BR>

<BR>
The <I>inline-assembler code</I> is also passed through the peep hole
optimizer, thus the peephole optimizer can also be used as an assembly
level macro expander. The rules themselves are MCU dependent whereas
the rule language infra-structure is MCU independent. Peephole optimization
rules for other MCU can be easily programmed using the rule language.
<BR>

<BR>
The syntax for a rule is as follows:
<BR>

<BR>
<TT>rule := replace [ restart ] '{' &lt;assembly sequence&gt; '&#92;n'
</TT>&nbsp;
<BR>
<TT>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; '}' by '{' '&#92;n'
</TT>&nbsp;
<BR>
<TT>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;assembly
sequence&gt; '&#92;n' </TT>&nbsp;
<BR>
<TT>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; '}' [if &lt;functionName&gt;
] '&#92;n' </TT>&nbsp;
<BR>

<BR>
&lt;assembly sequence&gt; := assembly instruction (each instruction including
labels must be on a separate line).
<BR>

<BR>
The optimizer will apply to the rules one by one from the top in the
sequence of their appearance, it will terminate when all rules are
exhausted. If the 'restart' option is specified, then the optimizer
will start matching the rules again from the top, this option for
a rule is expensive (performance), it is intended to be used in situations
where a transformation will trigger the same rule again. A good example
of this the following rule:
<BR>

<BR>
<TT>replace restart { </TT>&nbsp;
<BR>
<TT>&nbsp;&nbsp;pop %1 </TT>&nbsp;
<BR>
<TT>&nbsp;&nbsp;push %1 } by { </TT>&nbsp;
<BR>
<TT>&nbsp;&nbsp;; nop </TT>&nbsp;
<BR>
<TT>}</TT>
<BR>

<BR>
Note that the replace pattern cannot be a blank, but can be a comment
line. Without the 'restart' option only the inner most 'pop' 'push'
pair would be eliminated, i.e.:
<BR>

<BR>
<TT>&nbsp;&nbsp;pop ar1 </TT>&nbsp;
<BR>
<TT>&nbsp;&nbsp;pop ar2 </TT>&nbsp;
<BR>
<TT>&nbsp;&nbsp;push ar2 </TT>&nbsp;
<BR>
<TT>&nbsp;&nbsp;push ar1</TT>
<BR>

<BR>
would result in:
<BR>

<BR>
<TT>&nbsp;&nbsp;pop ar1 </TT>&nbsp;
<BR>
<TT>&nbsp;&nbsp;; nop </TT>&nbsp;
<BR>
<TT>&nbsp;&nbsp;push ar1</TT>
<BR>

<BR>
<I>with</I> the restart option the rule will be applied again to the
resulting code and then all the pop-push pairs will be eliminated
to yield:
<BR>

<BR>
<TT>&nbsp;&nbsp;; nop </TT>&nbsp;
<BR>
<TT>&nbsp;&nbsp;; nop</TT>
<BR>

<BR>
A conditional function can be attached to a rule. Attaching rules
are somewhat more involved, let me illustrate this with an example.
<BR>

<BR>
<TT>replace { </TT>&nbsp;
<BR>
<TT>&nbsp; &nbsp; &nbsp;ljmp %5 </TT>&nbsp;
<BR>
<TT>%2:</TT>&nbsp;
<BR>
<TT>} by { </TT>&nbsp;
<BR>
<TT>&nbsp; &nbsp; &nbsp;sjmp %5 </TT>&nbsp;
<BR>
<TT>%2:</TT>&nbsp;
<BR>
<TT>} if labelInRange</TT>
<BR>

<BR>
The optimizer does a look-up of a function name table defined in function
<I>callFuncByName</I> in the source file SDCCpeeph.c, with the name
<I>labelInRange</I>. If it finds a corresponding entry the function
is called. Note there can be no parameters specified for these functions,
in this case the use of <I>%5</I> is crucial, since the function
<I>labelInRange</I> expects to find the label in that particular variable
(the hash table containing the variable bindings is passed as a parameter).
If you want to code more such functions, take a close look at the
function labelInRange and the calling mechanism in source file SDCCpeeph.c.
I know this whole thing is a little kludgey, but maybe some day we
will have some better means. If you are looking at this file, you
will also see the default rules that are compiled into the compiler,
you can add your own rules in the default set there if you get tired
of specifying the -peep-file option.

<P>

<H2><A NAME="SECTION00052000000000000000">
4.2 Pragmas</A>
</H2>

<P>
SDCC supports the following #pragma directives. This directives are
applicable only at a function level.

<P>

<UL>
<LI>SAVE - this will save all the current options.</LI>
<LI>RESTORE - will restore the saved options from the last save. Note
that SAVES &amp; RESTOREs cannot be nested. SDCC uses the same buffer
to save the options each time a SAVE is called.</LI>
<LI>NOGCSE - will stop global subexpression elimination.</LI>
<LI>NOINDUCTION - will stop loop induction optimizations.</LI>
<LI>NOJTBOUND - will not generate code for boundary value checking, when
switch statements are turned into jump-tables.</LI>
<LI>NOOVERLAY - the compiler will not overlay the parameters and local
variables of a function.</LI>
<LI>NOLOOPREVERSE - Will not do loop reversal optimization</LI>
<LI>EXCLUDE NONE | {acc[,b[,dpl[,dph]]] - The exclude pragma
disables generation of pair of push/pop instruction in ISR function
(using interrupt keyword). The directive should be placed immediately
before the ISR function definition and it affects ALL ISR functions
following it. To enable the normal register saving for ISR functions
use #pragma&nbsp;EXCLUDE&nbsp;none.</LI>
<LI>CALLEE-SAVES function1[,function2[,function3...]] - The compiler
by default uses a caller saves convention for register saving across
function calls, however this can cause unneccessary register pushing
&amp; popping when calling small functions from larger functions. This
option can be used to switch the register saving convention for the
function names specified. The compiler will not save registers when
calling these functions, extra code will be generated at the entry
&amp; exit for these functions to save &amp; restore the registers used
by these functions, this can SUBSTANTIALLY reduce code &amp; improve
run time performance of the generated code. In future the compiler
(with interprocedural analysis) will be able to determine the appropriate
scheme to use for each function call. If -callee-saves command line
option is used, the function names specified in #pragma&nbsp;CALLEE-SAVES
is appended to the list of functions specified inthe command line.</LI>
</UL>
The pragma's are intended to be used to turn-off certain optimizations
which might cause the compiler to generate extra stack / data space
to store compiler generated temporary variables. This usually happens
in large functions. Pragma directives should be used as shown in the
following example, they are used to control options &amp; optimizations
for a given function; pragmas should be placed before and/or after
a function, placing pragma's inside a function body could have unpredictable
results.
<BR>

<BR>
<TT>#pragma SAVE /* save the current settings */ </TT>&nbsp;
<BR>
<TT>#pragma NOGCSE /* turnoff global subexpression elimination
*/ </TT>&nbsp;
<BR>
<TT>#pragma NOINDUCTION /* turn off induction optimizations
*/ </TT>&nbsp;
<BR>
<TT>int foo () </TT>&nbsp;
<BR>
<TT>{ </TT>&nbsp;
<BR>
<TT>&nbsp; &nbsp; ... </TT>&nbsp;
<BR>
<TT>&nbsp; &nbsp; /* large code */ </TT>&nbsp;
<BR>
<TT>&nbsp; &nbsp; ... </TT>&nbsp;
<BR>
<TT>} </TT>&nbsp;
<BR>
<TT>#pragma RESTORE /* turn the optimizations back on */</TT>
<BR>

<BR>
The compiler will generate a warning message when extra space is allocated.
It is strongly recommended that the SAVE and RESTORE pragma's be used
when changing options for a function.

<P>

<H2><A NAME="SECTION00053000000000000000">
4.3 <I>&lt;pending: this is messy and incomplete&gt;</I> Library Routines</A>
</H2>

<P>
The following library routines are provided for your convenience.

<P>
stdio.h - Contains the following functions printf &amp; sprintf these
routines are developed by Martijn van Balen &lt;balen@natlab.research.philips.com&gt;. 

<P>
 
%[flags][width][b|B|l|L]type

<P>
 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; flags: -&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; left justify output in
specified field width 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; prefix output with
+/- sign if output is signed type 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; space&nbsp;&nbsp;&nbsp; prefix output with a
blank if it's a signed positive value 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; width:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; specifies minimum number
of characters outputted for numbers 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; or strings. 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - For numbers,
spaces are added on the left when needed. 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If width starts
with a zero character, zeroes and used 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; instead of
spaces. 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - For strings,
spaces are are added on the left or right (when 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; flag '-' is
used) when needed. 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b/B:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; byte argument (used
by d, u, o, x, X) 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; l/L:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; long argument (used
by d, u, o, x, X)
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; type:&nbsp; d&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; decimal number 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; u&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned decimal
number 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; o&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned octal number

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned hexadecimal
number (0-9, a-f) 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; X&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned hexadecimal
number (0-9, A-F) 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; character 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; s&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; string (generic pointer)

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; generic pointer (I:data/idata,
C:code, X:xdata, P:paged) 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float (still to be
implemented)

<P>
Also contains a very simple version of printf (printf_small). This
simplified version of printf supports only the following formats.

<P>
format&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;output&nbsp;type&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;argument-type 
<BR>
%d &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;decimal &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; short/int 
<BR>
%ld&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;decimal&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;long 
<BR>
%hd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;decimal&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char 
<BR>
%x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hexadecimal&nbsp;&nbsp;&nbsp;&nbsp;short/int 
<BR>
%lx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hexadecimal&nbsp;&nbsp;&nbsp;&nbsp;long 
<BR>
%hx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hexadecimal&nbsp;&nbsp;&nbsp;&nbsp;char 
<BR>
%o&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;octal&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;short/int 
<BR>
%lo&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;octal&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;long 
<BR>
%ho&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;octal&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char 
<BR>
%c&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;character&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char 
<BR>
%s&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;character&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_generic pointer

<P>
The routine is very stack intesive, -stack-after-data parameter should
be used when using this routine, the routine also takes about 1K of
code space. It also expects an external function named putchar(char)
to be present (this can be changed). When using the %s format the
string / pointer should be cast to a generic pointer. eg.

<P>
printf_small(``my str %s, my int %d&#92;n'',(char
_generic *)mystr,myint);

<P>

<UL>
<LI>stdarg.h - contains definition for the following macros to be used
for variable parameter list, note that a function can have a variable
parameter list if and only if it is 'reentrant'

<P>
va_list, va_start, va_arg, va_end.

<P>
 </LI>
<LI>setjmp.h - contains defintion for ANSI setjmp &amp; longjmp routines.
Note in this case setjmp &amp; longjmp can be used between functions
executing within the same register bank, if long jmp is executed from
a function that is using a different register bank from the function
issuing the setjmp function, the results may be unpredictable. The
jump buffer requires 3 bytes of data (the stack pointer &amp; a 16 byte
return address), and can be placed in any address space.</LI>
<LI>stdlib.h - contains the following functions.

<P>
atoi, atol.

<P>
 </LI>
<LI>string.h - contains the following functions.

<P>
strcpy, strncpy, strcat, strncat, strcmp, strncmp, strchr, strrchr,
strspn, strcspn, strpbrk, strstr, strlen, strtok, memcpy, memcmp,
memset.

<P>
 </LI>
<LI>ctype.h - contains the following routines.

<P>
iscntrl, isdigit, isgraph, islower, isupper, isprint, ispunct, isspace,
isxdigit, isalnum, isalpha.

<P>
 </LI>
<LI>malloc.h - The malloc routines are developed by Dmitry S. Obukhov
(dso@usa.net). These routines will allocate memory from the external
ram. Here is a description on how to use them (as described by the
author).

<P>
 
//Example: 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp;&nbsp;&nbsp;&nbsp; #define DYNAMIC_MEMORY_SIZE 0x2000 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp;&nbsp;&nbsp;&nbsp; ..... 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp;&nbsp;&nbsp;&nbsp; unsigned char xdata dynamic_memory_pool[DYNAMIC_MEMORY_SIZE];

<BR>
&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp;&nbsp;&nbsp;&nbsp; unsigned char xdata * current_buffer; 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp;&nbsp;&nbsp;&nbsp; ..... 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp;&nbsp;&nbsp;&nbsp; void main(void) 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp;&nbsp;&nbsp;&nbsp; { 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ... 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; init_dynamic_memory(dynamic_memory_pool,DYNAMIC_MEMORY_SIZE);

<BR>
&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Now it's possible to use malloc. 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ... 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; current_buffer = malloc(0x100); 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp; //

<P>
 </LI>
<LI>serial.h - Serial IO routines are also developed by Dmitry S. Obukhov
(dso@usa.net). These routines are interrupt driven with a 256 byte
circular buffer, they also expect external ram to be present. Please
see documentation in file SDCCDIR/sdcc51lib/serial.c. Note the header
file ``serial.h'' MUST be included in the file containing the
'main' function.</LI>
<LI>ser.h - Alternate serial routine provided by Wolfgang Esslinger &lt;wolfgang@WiredMinds.com&gt;
these routines are more compact and faster. Please see documentation
in file SDCCDIR/sdcc51lib/ser.c</LI>
<LI>ser_ir.h - Another alternate set of serial routines provided by Josef
Wolf &lt;jw@raven.inka.de&gt;, these routines do not use the external ram.</LI>
<LI>reg51.h - contains register definitions for a standard 8051</LI>
<LI>float.h - contains min, max and other floating point related stuff.</LI>
</UL>
All library routines are compiled as -model-small, they are all non-reentrant,
if you plan to use the large model or want to make these routines
reentrant, then they will have to be recompiled with the appropriate
compiler option.

<P>
Have not had time to do the more involved routines like printf, will
get to them shortly.

<P>

<H2><A NAME="SECTION00054000000000000000">
4.4 Interfacing with Assembly Routines</A>
</H2>

<P>

<H3><A NAME="SECTION00054100000000000000">
4.4.1 Global Registers used for Parameter Passing</A>
</H3>

<P>
The compiler always uses the global registers <I>DPL,DPH,B</I> and
<I>ACC</I> to pass the first parameter to a routine. The second parameter
onwards is either allocated on the stack (for reentrant routines or
if -stack-auto is used) or in the internal / external ram (depending
on the memory model). 

<P>

<H3><A NAME="SECTION00054200000000000000">
4.4.2 Assembler Routine(non-reentrant)</A>
</H3>

<P>
In the following example the function cfunc calls an assembler routine
asm_func, which takes two parameters.
<BR>

<BR>
<TT>extern int asm_func(unsigned char, unsigned char);</TT>&nbsp;
<BR>&nbsp;
<BR>
<TT>int c_func (unsigned char i, unsigned char j)</TT>&nbsp;
<BR>
<TT>{</TT>&nbsp;
<BR>
<TT>&nbsp;&nbsp;&nbsp;&nbsp;return asm_func(i,j);</TT>&nbsp;
<BR>
<TT>}</TT>&nbsp;
<BR>&nbsp;
<BR>
<TT>int main()</TT>&nbsp;
<BR>
<TT>{</TT>&nbsp;
<BR>
<TT>&nbsp;&nbsp;&nbsp;&nbsp;return c_func(10,9);</TT>&nbsp;
<BR>
<TT>}</TT>&nbsp;
<BR>&nbsp;
<BR>
The corresponding assembler function is:
<BR>

<BR>
<TT>.globl _asm_func_PARM_2 </TT>&nbsp;
<BR>
<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.globl _asm_func </TT>&nbsp;
<BR>
<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.area OSEG </TT>&nbsp;
<BR>
<TT>_asm_func_PARM_2:</TT>&nbsp;
<BR>
<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.ds      1 </TT>&nbsp;
<BR>
<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.area CSEG </TT>&nbsp;
<BR>
<TT>_asm_func: </TT>&nbsp;
<BR>
<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov     a,dpl </TT>&nbsp;
<BR>
<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add     a,_asm_func_PARM_2 </TT>&nbsp;
<BR>
<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov     dpl,a </TT>&nbsp;
<BR>
<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov     dpl,#0x00 </TT>&nbsp;
<BR>
<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret</TT>&nbsp;
<BR>&nbsp;
<BR>
Note here that the return values are placed in 'dpl' - One byte return
value, 'dpl' LSB &amp; 'dph' MSB for two byte values. 'dpl', 'dph' and
'b' for three byte values (generic pointers) and 'dpl','dph','b' &amp;
'acc' for four byte values.

<P>
The parameter naming convention is _&lt;function_name&gt;_PARM_&lt;n&gt;,
where n is the parameter number starting from 1, and counting from
the left. The first parameter is passed in ``dpl'' for One bye
parameter, ``dptr'' if two bytes, ``b,dptr'' for three bytes
and ``acc,b,dptr'' for four bytes, the varible name for the second
parameter will be _&lt;function_name&gt;_PARM_2.
<BR>

<BR>
Assemble the assembler routine with the following command:
<BR>

<BR>
<I><B>asx8051 -losg asmfunc.asm</B></I>
<BR>
<BR>
Then compile and link the assembler routine to the C source file with
the following command:
<BR>

<BR>
<I><B>sdcc cfunc.c asmfunc.rel</B></I>

<P>

<H3><A NAME="SECTION00054300000000000000">
4.4.3 Assembler Routine(reentrant)</A>
</H3>

<P>
In this case the second parameter onwards will be passed on the stack,
the parameters are pushed from right to left i.e. after the call the
left most parameter will be on the top of the stack. Here is an example:
<BR>

<BR>
<TT>extern int asm_func(unsigned char, unsigned char);</TT>&nbsp;
<BR>&nbsp;
<BR>
<TT>int c_func (unsigned char i, unsigned char j) reentrant </TT>&nbsp;
<BR>
<TT>{ </TT>&nbsp;
<BR>
<TT>&nbsp;&nbsp;&nbsp;&nbsp;return asm_func(i,j); </TT>&nbsp;
<BR>
<TT>} </TT>&nbsp;
<BR>&nbsp;
<BR>
<TT>int main() </TT>&nbsp;
<BR>
<TT>{ </TT>&nbsp;
<BR>
<TT>&nbsp;&nbsp;&nbsp;&nbsp;return c_func(10,9); </TT>&nbsp;
<BR>
<TT>}</TT>&nbsp;
<BR>

<BR>
The corresponding assembler routine is:
<BR>

<BR>
<TT>.globl _asm_func </TT>&nbsp;
<BR>
<TT>_asm_func: </TT>&nbsp;
<BR>
<TT>&nbsp;&nbsp;&nbsp;&nbsp;push  _bp </TT>&nbsp;
<BR>
<TT>&nbsp;&nbsp;&nbsp;&nbsp;mov  _bp,sp </TT>&nbsp;
<BR>
<TT>&nbsp;&nbsp;&nbsp;&nbsp;mov  r2,dpl</TT>&nbsp;
<BR>
<TT>&nbsp;&nbsp;&nbsp;&nbsp;mov  a,_bp </TT>&nbsp;
<BR>
<TT>&nbsp;&nbsp;&nbsp;&nbsp;clr  c </TT>&nbsp;
<BR>
<TT>&nbsp;&nbsp;&nbsp;&nbsp;add  a,#0xfd </TT>&nbsp;
<BR>
<TT>&nbsp;&nbsp;&nbsp;&nbsp;mov  r0,a </TT>&nbsp;
<BR>
<TT>&nbsp;&nbsp;&nbsp;&nbsp;add  a,#0xfc</TT>&nbsp;
<BR>
<TT>&nbsp;&nbsp;&nbsp;&nbsp;mov  r1,a </TT>&nbsp;
<BR>
<TT>&nbsp;&nbsp;&nbsp;&nbsp;mov  a,@r0 </TT>&nbsp;
<BR>
<TT>&nbsp;&nbsp;&nbsp;&nbsp;add  a,r2</TT>&nbsp;
<BR>
<TT>&nbsp;&nbsp;&nbsp;&nbsp;mov  dpl,a </TT>&nbsp;
<BR>
<TT>&nbsp;&nbsp;&nbsp;&nbsp;mov  dph,#0x00 </TT>&nbsp;
<BR>
<TT>&nbsp;&nbsp;&nbsp;&nbsp;mov  sp,_bp </TT>&nbsp;
<BR>
<TT>&nbsp;&nbsp;&nbsp;&nbsp;pop  _bp </TT>&nbsp;
<BR>
<TT>&nbsp;&nbsp;&nbsp;&nbsp;ret</TT>&nbsp;
<BR>&nbsp;
<BR>
The compiling and linking procedure remains the same, however note
the extra entry &amp; exit linkage required for the assembler code, _bp
is the stack frame pointer and is used to compute the offset into
the stack for parameters and local variables.

<P>

<H2><A NAME="SECTION00055000000000000000">
4.5 External Stack</A>
</H2>

<P>
The external stack is located at the start of the external ram segment,
and is 256 bytes in size. When -xstack option is used to compile
the program, the parameters and local variables of all reentrant functions
are allocated in this area. This option is provided for programs with
large stack space requirements. When used with the -stack-auto option,
all parameters and local variables are allocated on the external stack
(note support libraries will need to be recompiled with the same options).

<P>
The compiler outputs the higher order address byte of the external
ram segment into PORT P2, therefore when using the External Stack
option, this port MAY NOT be used by the application program.

<P>

<H2><A NAME="SECTION00056000000000000000">
4.6 ANSI-Compliance</A>
</H2>

<P>
Deviations from the compliancy.

<P>

<UL>
<LI>functions are not always reentrant.</LI>
<LI>structures cannot be assigned values directly, cannot be passed as
function parameters or assigned to each other and cannot be a return
value from a function, e.g.:&nbsp;
<BR>&nbsp;
<BR>
<TT>struct s { ... }; </TT>&nbsp;
<BR>
<TT>struct s s1, s2; </TT>&nbsp;
<BR>
<TT>foo() </TT>&nbsp;
<BR>
<TT>{ </TT>&nbsp;
<BR>
<TT>&nbsp;&nbsp;&nbsp;&nbsp;... </TT>&nbsp;
<BR>
<TT>&nbsp;&nbsp;&nbsp;&nbsp;s1 = s2 ; /* is invalid in SDCC although allowed
in ANSI */ </TT>&nbsp;
<BR>
<TT>&nbsp;&nbsp;&nbsp;&nbsp;... </TT>&nbsp;
<BR>
<TT>}</TT>&nbsp;
<BR>
<TT>struct s foo1 (struct s parms) /* is invalid in SDCC although
allowed in ANSI */ </TT>&nbsp;
<BR>
<TT>{ </TT>&nbsp;
<BR>
<TT>&nbsp;&nbsp;&nbsp;&nbsp;struct s rets; </TT>&nbsp;
<BR>
<TT>&nbsp;&nbsp;&nbsp;&nbsp;... </TT>&nbsp;
<BR>
<TT>&nbsp;&nbsp;&nbsp;&nbsp;return rets;/* is invalid in SDCC although allowed
in ANSI */ </TT>&nbsp;
<BR>
<TT>}</TT></LI>
<LI>'long long' (64 bit integers) not supported.</LI>
<LI>'double' precision floating point not supported.</LI>
<LI>No support for setjmp and longjmp (for now).</LI>
<LI>Old K&amp;R style function declarations are NOT allowed.
<BR>&nbsp;
<BR>
<TT>foo(i,j) /* this old style of function declarations */
</TT>&nbsp;
<BR>
<TT>int i,j; /* are valid in ANSI but not valid in SDCC */
</TT>&nbsp;
<BR>
<TT>{ </TT>&nbsp;
<BR>
<TT>&nbsp;&nbsp;&nbsp;&nbsp;... </TT>&nbsp;
<BR>
<TT>}</TT></LI>
<LI>functions declared as pointers must be dereferenced during the call.
<BR>&nbsp;
<BR>
<TT>int (*foo)();</TT>&nbsp;
<BR>
<TT>... </TT>&nbsp;
<BR>
<TT>/* has to be called like this */ </TT>&nbsp;
<BR>
<TT>(*foo)(); /* ansi standard allows calls to be made like
'foo()' */</TT></LI>
</UL>

<P>

<H2><A NAME="SECTION00057000000000000000">
4.7 Cyclomatic Complexity</A>
</H2>

<P>
Cyclomatic complexity of a function is defined as the number of independent
paths the program can take during execution of the function. This
is an important number since it defines the number test cases you
have to generate to validate the function. The accepted industry standard
for complexity number is 10, if the cyclomatic complexity reported
by SDCC exceeds 10 you should think about simplification of the function
logic. Note that the complexity level is not related to the number
of lines of code in a function. Large functions can have low complexity,
and small functions can have large complexity levels. 
<BR>

<BR>
SDCC uses the following formula to compute the complexity:
<BR>

<P>
complexity = (number of edges in control flow graph) - (number of
nodes in control flow graph) + 2;
<BR>

<BR>
Having said that the industry standard is 10, you should be aware
that in some cases it be may unavoidable to have a complexity level
of less than 10. For example if you have switch statement with more
than 10 case labels, each case label adds one to the complexity level.
The complexity level is by no means an absolute measure of the algorithmic
complexity of the function, it does however provide a good starting
point for which functions you might look at for further optimization.

<P>

<H1><A NAME="SECTION00060000000000000000">
5. TIPS</A>
</H1>

<P>
Here are a few guidelines that will help the compiler generate more
efficient code, some of the tips are specific to this compiler others
are generally good programming practice.

<P>

<UL>
<LI>Use the smallest data type to represent your data-value. If it is
known in advance that the value is going to be less than 256 then
use a 'char' instead of a 'short' or 'int'.</LI>
<LI>Use unsigned when it is known in advance that the value is not going
to be negative. This helps especially if you are doing division or
multiplication.</LI>
<LI>NEVER jump into a LOOP.</LI>
<LI>Declare the variables to be local whenever possible, especially loop
control variables (induction).</LI>
<LI>Since the compiler does not do implicit integral promotion, the programmer
should do an explicit cast when integral promotion is required.</LI>
<LI>Reducing the size of division, multiplication &amp; modulus operations
can reduce code size substantially. Take the following code for example.&nbsp;
<BR>&nbsp;
<BR>
<TT>foobar(unsigned int p1, unsigned char ch)</TT>&nbsp;
<BR>
<TT>{</TT>&nbsp;
<BR>
 <TT>   unsigned char ch1 = p1 % ch ;</TT>&nbsp;
<BR>
 <TT>   ....    </TT>&nbsp;
<BR>
<TT>}</TT>&nbsp;
<BR>

<BR>
For the modulus operation the variable ch will be promoted to unsigned
int first then the modulus operation will be performed (this will
lead to a call to support routine _muduint()), and the result will
be casted to an int. If the code is changed to 
<BR>&nbsp;
<BR>
<TT>foobar(unsigned int p1, unsigned char ch)</TT>&nbsp;
<BR>
<TT>{</TT>&nbsp;
<BR>
 <TT>   unsigned char ch1 = (unsigned char)p1 % ch ;</TT>&nbsp;
<BR>
 <TT>   ....    </TT>&nbsp;
<BR>
<TT>}</TT>&nbsp;
<BR>

<BR>
It would substantially reduce the code generated (future versions
of the compiler will be smart enough to detect such optimization oppurtunities).</LI>
</UL>

<P>

<H2><A NAME="SECTION00061000000000000000">
5.1 Notes on MCS51 memory layout</A>
</H2>

<P>
The 8051 family of micro controller have a minimum of 128 bytes of
internal memory which is structured as follows
<BR>

<BR>
- Bytes 00-1F - 32 bytes to hold up to 4 banks of the registers R7
to R7 
<BR>
- Bytes 20-2F - 16 bytes to hold 128 bit variables and 
<BR>
- Bytes 30-7F - 60 bytes for general purpose use.
<BR>

<BR>
Normally the SDCC compiler will only utilise the first bank of registers,
but it is possible to specify that other banks of registers should
be used in interrupt routines. By default, the compiler will place
the stack after the last bank of used registers, i.e. if the first
2 banks of registers are used, it will position the base of the internal
stack at address 16 (0X10). This implies that as the stack grows,
it will use up the remaining register banks, and the 16 bytes used
by the 128 bit variables, and 60 bytes for general purpose use.

<P>
By default, the compiler uses the 60 general purpose bytes to hold
&#34;near data&#34;. The compiler/optimiser may also declare
some Local Variables in this area to hold local data. 

<P>
If any of the 128 bit variables are used, or near data is being used
then care needs to be taken to ensure that the stack does not grow
so much that it starts to over write either your bit variables or
&#34;near data&#34;. There is no runtime checking to prevent
this from happening.

<P>
The amount of stack being used is affected by the use of the &#34;internal
stack&#34; to save registers before a subroutine call is made
(-stack-auto will declare parameters and local variables on the stack)
and the number of nested subroutines.

<P>
If you detect that the stack is over writing you data, then the following
can be done. -xstack will cause an external stack to be used for
saving registers and (if -stack-auto is being used) storing parameters
and local variables. However this will produce more code which will
be slower to execute. 

<P>
 
-stack-loc will allow you specify the start of the stack, i.e. you
could start it after any data in the general purpose area. However
this may waste the memory not used by the register banks and if the
size of the &#34;near data&#34; increases, it may creep
into the bottom of the stack.

<P>
 
-stack-after-data, similar to the -stack-loc, but it automatically
places the stack after the end of the &#34;near data&#34;.
Again this could waste any spare register space.

<P>
 
-data-loc allows you to specify the start address of the near data.
This could be used to move the &#34;near data&#34; further
away from the stack giving it more room to grow. This will only work
if no bit variables are being used and the stack can grow to use the
bit variable space.
<BR>

<BR>
Conclusion.
<BR>

<BR>
If you find that the stack is over writing your bit variables or &#34;near
data&#34; then the approach which best utilised the internal
memory is to position the &#34;near data&#34; after the
last bank of used registers or, if you use bit variables, after the
last bit variable by using the -data-loc, e.g. if two register banks
are being used and no bit variables, -data-loc 16, and use the -stack-after-data
option.

<P>
If bit variables are being used, another method would be to try and
squeeze the data area in the unused register banks if it will fit,
and start the stack after the last bit variable.

<P>

<H1><A NAME="SECTION00070000000000000000">
6. Retargetting for other MCUs.</A>
</H1>

<P>
The issues for retargetting the compiler are far too numerous to be
covered by this document. What follows is a brief description of each
of the seven phases of the compiler and its MCU dependency.

<P>

<UL>
<LI>Parsing the source and building the annotated parse tree. This phase
is largely MCU independent (except for the language extensions). Syntax
&amp; semantic checks are also done in this phase, along with some initial
optimizations like back patching labels and the pattern matching optimizations
like bit-rotation etc.</LI>
<LI>The second phase involves generating an intermediate code which can
be easy manipulated during the later phases. This phase is entirely
MCU independent. The intermediate code generation assumes the target
machine has unlimited number of registers, and designates them with
the name iTemp. The compiler can be made to dump a human readable
form of the code generated by using the -dumpraw option.</LI>
<LI>This phase does the bulk of the standard optimizations and is also
MCU independent. This phase can be broken down into several sub-phases:
<BR>

<BR>
Break down intermediate code (iCode) into basic blocks.
<BR>
Do control flow &amp; data flow analysis on the basic blocks.
<BR>
Do local common subexpression elimination, then global subexpression
elimination
<BR>
Dead code elimination
<BR>
Loop optimizations
<BR>
If loop optimizations caused any changes then do 'global subexpression
elimination' and 'dead code elimination' again.</LI>
<LI>This phase determines the live-ranges; by live range I mean those
iTemp variables defined by the compiler that still survive after all
the optimizations. Live range analysis is essential for register allocation,
since these computation determines which of these iTemps will be assigned
to registers, and for how long.</LI>
<LI>Phase five is register allocation. There are two parts to this process.
<BR>

<BR>
The first part I call 'register packing' (for lack of a better term).
In this case several MCU specific expression folding is done to reduce
register pressure.
<BR>

<BR>
The second part is more MCU independent and deals with allocating
registers to the remaining live ranges. A lot of MCU specific code
does creep into this phase because of the limited number of index
registers available in the 8051.</LI>
<LI>The Code generation phase is (unhappily), entirely MCU dependent and
very little (if any at all) of this code can be reused for other MCU.
However the scheme for allocating a homogenized assembler operand
for each iCode operand may be reused.</LI>
<LI>As mentioned in the optimization section the peep-hole optimizer is
rule based system, which can reprogrammed for other MCUs.</LI>
</UL>

<P>

<H1><A NAME="SECTION00080000000000000000">
7. SDCDB - Source Level Debugger</A>
</H1>

<P>
SDCC is distributed with a source level debugger. The debugger uses
a command line interface, the command repertoire of the debugger has
been kept as close to gdb (the GNU debugger) as possible. The configuration
and build process is part of the standard compiler installation, which
also builds and installs the debugger in the target directory specified
during configuration. The debugger allows you debug BOTH at the C
source and at the ASM source level.

<P>

<H2><A NAME="SECTION00081000000000000000">
7.1 Compiling for Debugging</A>
</H2>

<P>
The debug option must be specified for all files for which debug
information is to be generated. The complier generates a .cdb file
for each of these files. The linker updates the .cdb file with the
address information. This .cdb is used by the debugger.

<P>

<H2><A NAME="SECTION00082000000000000000">
7.2 How the Debugger Works</A>
</H2>

<P>
When the -debug option is specified the compiler generates extra
symbol information some of which are put into the the assembler source
and some are put into the .cdb file, the linker updates the .cdb file
with the address information for the symbols. The debugger reads the
symbolic information generated by the compiler &amp; the address information
generated by the linker. It uses the SIMULATOR (Daniel's S51) to execute
the program, the program execution is controlled by the debugger.
When a command is issued for the debugger, it translates it into appropriate
commands for the simulator.

<P>

<H2><A NAME="SECTION00083000000000000000">
7.3 Starting the Debugger</A>
</H2>

<P>
The debugger can be started using the following command line. (Assume
the file you are debugging has the file name foo).
<BR>

<BR>
<I><B>sdcdb foo</B></I>
<BR>

<BR>
The debugger will look for the following files.

<P>

<UL>
<LI>foo.c - the source file.</LI>
<LI>foo.cdb - the debugger symbol information file.</LI>
<LI>foo.ihx - the intel hex format object file.</LI>
</UL>

<P>

<H2><A NAME="SECTION00084000000000000000">
7.4 Command Line Options.</A>
</H2>

<P>

<UL>
<LI>-directory=&lt;source file directory&gt; this option can used to specify
the directory search list. The debugger will look into the directory
list specified for source, cdb &amp; ihx files. The items in the directory
list must be separated by ':', e.g. if the source files can be in
the directories /home/src1 and /home/src2, the -directory option
should be -directory=/home/src1:/home/src2. Note there can be no
spaces in the option. </LI>
<LI>-cd &lt;directory&gt; - change to the &lt;directory&gt;.</LI>
<LI>-fullname - used by GUI front ends.</LI>
<LI>-cpu &lt;cpu-type&gt; - this argument is passed to the simulator please
see the simulator docs for details.</LI>
<LI>-X &lt;Clock frequency &gt; this options is passed to the simulator please
see the simulator docs for details.</LI>
<LI>-s &lt;serial port file&gt; passed to simulator see the simulator docs for
details.</LI>
<LI>-S &lt;serial in,out&gt; passed to simulator see the simulator docs for
details.</LI>
</UL>

<P>

<H2><A NAME="SECTION00085000000000000000">
7.5 Debugger Commands.</A>
</H2>

<P>
As mention earlier the command interface for the debugger has been
deliberately kept as close the GNU debugger gdb, as possible. This
will help the integration with existing graphical user interfaces
(like ddd, xxgdb or xemacs) existing for the GNU debugger.

<P>

<H3><A NAME="SECTION00085100000000000000">
7.5.1 break [line | file:line | function | file:function]</A>
</H3>

<P>
Set breakpoint at specified line or function:
<BR>

<BR>
<I><B>sdcdb&gt;break 100 </B></I>
<BR>
<I><B>sdcdb&gt;break foo.c:100</B></I>
<BR>
<I><B>sdcdb&gt;break funcfoo</B></I>
<BR>
<I><B>sdcdb&gt;break foo.c:funcfoo</B></I>

<P>

<H3><A NAME="SECTION00085200000000000000">
7.5.2 clear [line | file:line | function | file:function ]</A>
</H3>

<P>
Clear breakpoint at specified line or function:
<BR>

<BR>
<I><B>sdcdb&gt;clear 100</B></I>
<BR>
<I><B>sdcdb&gt;clear foo.c:100</B></I>
<BR>
<I><B>sdcdb&gt;clear funcfoo</B></I>
<BR>
<I><B>sdcdb&gt;clear foo.c:funcfoo</B></I>

<P>

<H3><A NAME="SECTION00085300000000000000">
7.5.3 continue</A>
</H3>

<P>
Continue program being debugged, after breakpoint.

<P>

<H3><A NAME="SECTION00085400000000000000">
7.5.4 finish</A>
</H3>

<P>
Execute till the end of the current function.

<P>

<H3><A NAME="SECTION00085500000000000000">
7.5.5 delete [n]</A>
</H3>

<P>
Delete breakpoint number 'n'. If used without any option clear ALL
user defined break points.

<P>

<H3><A NAME="SECTION00085600000000000000">
7.5.6 info [break | stack | frame | registers ]</A>
</H3>

<P>

<UL>
<LI>info break - list all breakpoints</LI>
<LI>info stack - show the function call stack.</LI>
<LI>info frame - show information about the current execution frame.</LI>
<LI>info registers - show content of all registers.</LI>
</UL>

<P>

<H3><A NAME="SECTION00085700000000000000">
7.5.7 step</A>
</H3>

<P>
Step program until it reaches a different source line.

<P>

<H3><A NAME="SECTION00085800000000000000">
7.5.8 next</A>
</H3>

<P>
Step program, proceeding through subroutine calls.

<P>

<H3><A NAME="SECTION00085900000000000000">
7.5.9 run</A>
</H3>

<P>
Start debugged program.

<P>

<H3><A NAME="SECTION000851000000000000000">
7.5.10 ptype variable </A>
</H3>

<P>
Print type information of the variable.

<P>

<H3><A NAME="SECTION000851100000000000000">
7.5.11 print variable</A>
</H3>

<P>
print value of variable.

<P>

<H3><A NAME="SECTION000851200000000000000">
7.5.12 file filename</A>
</H3>

<P>
load the given file name. Note this is an alternate method of loading
file for debugging.

<P>

<H3><A NAME="SECTION000851300000000000000">
7.5.13 frame</A>
</H3>

<P>
print information about current frame.

<P>

<H3><A NAME="SECTION000851400000000000000">
7.5.14 set srcmode</A>
</H3>

<P>
Toggle between C source &amp; assembly source.

<P>

<H3><A NAME="SECTION000851500000000000000">
7.5.15 ! simulator command</A>
</H3>

<P>
Send the string following '!' to the simulator, the simulator response
is displayed. Note the debugger does not interpret the command being
sent to the simulator, so if a command like 'go' is sent the debugger
can loose its execution context and may display incorrect values.

<P>

<H3><A NAME="SECTION000851600000000000000">
7.5.16 quit.</A>
</H3>

<P>
 
&#34;Watch me now. Iam going Down. My name is Bobby Brown&#34;

<P>

<H2><A NAME="SECTION00086000000000000000">
7.6 Interfacing with XEmacs.</A>
</H2>

<P>
Two files (in emacs lisp) are provided for the interfacing with XEmacs,
sdcdb.el and sdcdbsrc.el. These two files can be found in the $(prefix)/bin
directory after the installation is complete. These files need to
be loaded into XEmacs for the interface to work. This can be done
at XEmacs startup time by inserting the following into your '.xemacs'
file (which can be found in your HOME directory): 
<BR>

<BR>
<TT>(load-file sdcdbsrc.el)</TT> 
<BR>

<BR>
.xemacs is a lisp file so the () around the command is REQUIRED. The
files can also be loaded dynamically while XEmacs is running, set
the environment variable 'EMACSLOADPATH' to the installation bin directory
(&lt;installdir&gt;/bin), then enter the following command ESC-x load-file
sdcdbsrc. To start the interface enter the following command: 
<BR>

<BR>
<I><B>ESC-x sdcdbsrc</B></I>
<BR>

<BR>
You will prompted to enter the file name to be debugged. 
<BR>

<BR>
The command line options that are passed to the simulator directly
are bound to default values in the file sdcdbsrc.el. The variables
are listed below, these values maybe changed as required.

<P>

<UL>
<LI>sdcdbsrc-cpu-type '51</LI>
<LI>sdcdbsrc-frequency '11059200</LI>
<LI>sdcdbsrc-serial nil</LI>
</UL>
The following is a list of key mapping for the debugger interface.

<P>
 
&nbsp;&nbsp;
<BR>
<TT>;; Current Listing :: </TT>&nbsp;
<BR>
<TT>;;key&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;binding&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Comment
</TT>&nbsp;
<BR>
<TT>;;--&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;----&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;----
</TT>&nbsp;
<BR>
<TT>;; </TT>&nbsp;
<BR>
<TT>;; n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sdcdb-next-from-src&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SDCDB
next command </TT>&nbsp;
<BR>
<TT>;; b&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sdcdb-back-from-src&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SDCDB
back command </TT>&nbsp;
<BR>
<TT>;; c&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sdcdb-cont-from-src&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SDCDB
continue command</TT>&nbsp;
<BR>
<TT>;; s&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sdcdb-step-from-src&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SDCDB
step command </TT>&nbsp;
<BR>
<TT>;; ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sdcdb-whatis-c-sexp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SDCDB
ptypecommand for data at </TT>&nbsp;
<BR>
<TT>;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
buffer point </TT>&nbsp;
<BR>
<TT>;; x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sdcdbsrc-delete&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SDCDB
Delete all breakpoints if no arg </TT>&nbsp;
<BR>
<TT>;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;given
or delete arg (C-u arg x) </TT>&nbsp;
<BR>
<TT>;; m&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sdcdbsrc-frame&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SDCDB
Display current frame if no arg, </TT>&nbsp;
<BR>
<TT>;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;given
or display frame arg </TT>&nbsp;
<BR>
<TT>;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buffer
point </TT>&nbsp;
<BR>
<TT>;; !&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sdcdbsrc-goto-sdcdb&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Goto
the SDCDB output buffer </TT>&nbsp;
<BR>
<TT>;; p&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sdcdb-print-c-sexp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SDCDB
print command for data at </TT>&nbsp;
<BR>
<TT>;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
buffer point </TT>&nbsp;
<BR>
<TT>;; g&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sdcdbsrc-goto-sdcdb&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Goto
the SDCDB output buffer </TT>&nbsp;
<BR>
<TT>;; t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sdcdbsrc-mode&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Toggles
Sdcdbsrc mode (turns it off) </TT>&nbsp;
<BR>
<TT>;; </TT>&nbsp;
<BR>
<TT>;; C-c C-f&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sdcdb-finish-from-src&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SDCDB
finish command </TT>&nbsp;
<BR>
<TT>;; </TT>&nbsp;
<BR>
<TT>;; C-x SPC&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sdcdb-break&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set
break for line with point </TT>&nbsp;
<BR>
<TT>;; ESC t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sdcdbsrc-mode&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Toggle
Sdcdbsrc mode </TT>&nbsp;
<BR>
<TT>;; ESC m&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sdcdbsrc-srcmode&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Toggle list mode </TT>&nbsp;
<BR>
<TT>;;</TT> 
<BR>

<P>

<H1><A NAME="SECTION00090000000000000000">
8. Other Processors</A>
</H1>

<P>

<H2><A NAME="SECTION00091000000000000000">
8.1 The Z80 and gbz80 port</A>
</H2>

<P>
SDCC can target both the Zilog Z80 and the Nintendo Gameboy's Z80-like
gbz80. The port is incomplete - long support is incomplete (mul, div
and mod are unimplimented), and both float and bitfield support is
missing. Apart from that the code generated is correct.

<P>
As always, the code is the authoritave reference - see z80/ralloc.c
and z80/gen.c. The stack frame is similar to that generated by the
IAR Z80 compiler. IX is used as the base pointer, HL is used as a
temporary register, and BC and DE are available for holding varibles.
IY is currently unusued. Return values are stored in HL. One bad side
effect of using IX as the base pointer is that a functions stack frame
is limited to 127 bytes - this will be fixed in a later version.

<P>

<H1><A NAME="SECTION000100000000000000000">
9. Support</A>
</H1>

<P>
SDCC has grown to be a large project. The compiler alone (without
the preprocessor, assembler and linker) is about 40,000 lines of code
(blank stripped). The open source nature of this project is a key
to its continued growth and support. You gain the benefit and support
of many active software developers and end users. Is SDCC perfect?
No, that's why we need your help. The developers take pride in fixing
reported bugs. You can help by reporting the bugs and helping other
SDCC users. There are lots of ways to contribute, and we encourage
you to take part in making SDCC a great software package.

<P>

<H2><A NAME="SECTION000101000000000000000">
9.1 Reporting Bugs</A>
</H2>

<P>
Send an email to the mailing list at 'user-sdcc@sdcc.sourceforge.net'
or 'devel-sdcc@sdcc.sourceforge.net'. Bugs will be fixed ASAP. When
reporting a bug, it is very useful to include a small test program
which reproduces the problem. If you can isolate the problem by looking
at the generated assembly code, this can be very helpful. Compiling
your program with the -dumpall option can sometimes be useful in
locating optimization problems.

<P>

<H1><A NAME="SECTION000110000000000000000">
10. Acknowledgments</A>
</H1>

<P>
Sandeep Dutta (sandeep.dutta@usa.net) - SDCC, the compiler, MCS51
code generator, Debugger, AVR port
<BR>
Alan Baldwin (baldwin@shop-pdp.kent.edu) - Initial version of ASXXXX
&amp; ASLINK. 
<BR>
John Hartman (jhartman@compuserve.com) - Porting ASXXX &amp; ASLINK for
8051
<BR>
Dmitry S. Obukhov (dso@usa.net) - malloc &amp; serial i/o routines. 
<BR>
Daniel Drotos (drdani@mazsola.iit.uni-miskolc.hu) - for his Freeware
simulator
<BR>
Malini Dutta(malini_dutta@hotmail.com) - my wife for her patience
and support.
<BR>
Unknown - for the GNU C - preprocessor.
<BR>
Michael Hope - The Z80 and Z80GB port, 186 development
<BR>
Kevin Vigor - The DS390 port.
<BR>
Johan Knol - Lots of fixes and enhancements, DS390/TINI libs.
<BR>
Scott Datallo - The PIC port.
<BR>

<BR>
<I>Thanks to all the other volunteer developers who have helped
with coding, testing, web-page creation, distribution sets, etc. You
know who you are :-)</I>
<BR>

<P>
This document was initially written by Sandeep Dutta

<P>
All product names mentioned herein may be trademarks of their respective
companies. 

<P>
<BR>

<H2><A NAME="SECTION000120000000000000000">
Index</A>
</H2><DL COMPACT>
<DT><STRONG>index</STRONG>
<DD><A HREF="SDCCUdoc.html#67">1.7 Wishes for the</A>

</DL>

<H1><A NAME="SECTION000130000000000000000">
About this document ...</A>
</H1>
 <STRONG>SDCC Compiler User Guide</STRONG><P>
This document was generated using the
<A HREF="http://www-dsed.llnl.gov/files/programs/unix/latex2html/manual/"><STRONG>LaTeX</STRONG>2<tt>HTML</tt></A> translator Version 99.1 release (March 30, 1999)
<P>
Copyright &#169; 1993, 1994, 1995, 1996,
<A HREF="http://cbl.leeds.ac.uk/nikos/personal.html">Nikos Drakos</A>, 
Computer Based Learning Unit, University of Leeds.
<BR>
Copyright &#169; 1997, 1998, 1999,
<A HREF="http://www.maths.mq.edu.au/~ross/">Ross Moore</A>, 
Mathematics Department, Macquarie University, Sydney.
<P>
The command line arguments were: <BR>
 <STRONG>latex2html</STRONG> <TT>-split 0 -show_section_numbers -dir fullhtml SDCCUdoc</TT>
<P>
The translation was initiated by Johan Knol on 2001-07-07
<BR><HR><H4>Footnotes</H4>
<DL>
<DT><A NAME="foot530">...
anyway</A><A NAME="foot530"
 HREF="SDCCUdoc.html#tex2html1"><SUP>1</SUP></A>
<DD>possible exception: if a function is called ONLY from 'interrupt'
functions using a particular bank, it can be declared with the same
'using' attribute as the calling 'interrupt' functions. For instance,
if you have several ISRs using bank one, and all of them call memcpy(),
it might make sense to create a specialized version of memcpy() 'using
1', since this would prevent the ISR from having to save bank zero
to the stack on entry and switch to bank zero before calling the function


</DL><HR>
<!--Navigation Panel-->
<IMG WIDTH="81" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next_group"
 SRC="/home/johan/latex2html/icons.gif/next_group_motif_gr.gif"> 
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up"
 SRC="/home/johan/latex2html/icons.gif/up_motif_gr.gif"> 
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous"
 SRC="/home/johan/latex2html/icons.gif/previous_motif_gr.gif">   
<BR>
<!--End of Navigation Panel-->
<ADDRESS>
<I>Johan Knol</I>
<BR><I>2001-07-07</I>
</ADDRESS>
</BODY>
</HTML>
