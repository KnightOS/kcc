// peeph.def - STM8 peephole rules

replace restart {
	ld	%1, %2
} by {
	; peephole 0 removed dead load.
} if notVolatile(%1), notVolatile(%2), notUsed(%1)

//replace restart {
//	ld	%1, %2
//	ld	%3, %1
//} by {
//	; peephole 0' loaded %3 from %2 directly instead of going through %1.
//	ld	%3, %2
//} if canAssign(%3 %2), notVolatile(%1), notUsed(%1)

replace restart {
	pop	%1
	push	%1
} by {
	; peephole 1 removed dead pop / push pair.
} if notUsed(%1)

replace restart {
	popw	%1
	pushw	%1
} by {
	; peephole 1a removed dead popw / pushw pair.
} if notUsed(%1)

replace restart {
	ld	a, %1
	cpl	a
	ld	%1, a
} by {
	cpl	%1
	; peephole 2 complemented in %1 instead of a.
} if notUsed('a'), notSame(%1 'xl' 'xh' 'yl' 'yh')

replace restart {
	ld	a, %1
	dec	a
	ld	%1, a
} by {
	dec	%1
	; peephole 3 decremented in %1 instead of a.
} if notUsed('a'), notSame(%1 'xl' 'xh' 'yl' 'yh')

replace restart {
	ld	a, %1
	inc	a
	ld	%1, a
} by {
	inc	%1
	; peephole 4 incremented in %1 instead of a.
} if notUsed('a'), notSame(%1 'xl' 'xh' 'yl' 'yh')

replace restart {
	ld	a, %1
	neg	a
	ld	%1, a
} by {
	neg	%1
	; peephole 5 negated in %1 instead of a.
} if notUsed('a'), notSame(%1, 'xl' 'xh' 'yl' 'yh')

replace restart {
	ld	a, %1
	rlc	a
	ld	%1, a
} by {
	rlc	%1
	; peephole 6 rotated in %1 instead of a.
} if notUsed('a'), notSame(%1 'xl' 'xh' 'yl' 'yh')

replace restart {
	ld	a, %1
	rrc	a
	ld	%1, a
} by {
	rrc	%1
	; peephole 7 rotated in %1 instead of a.
} if notUsed('a'), notSame(%1, 'xl' 'xh' 'yl' 'yh')

replace restart {
	ld	a, %1
	sll	a
	ld	%1, a
} by {
	sll	%1
	; peephole 8 shifted in %1 instead of a.
} if notUsed('a'), notSame(%1 'xl' 'xh' 'yl' 'yh')

replace restart {
	ld	a, %1
	sra	a
	ld	%1, a
} by {
	sra	%1
	; peephole 9 shifted in %1 instead of a.
} if notUsed('a'), notSame(%1 'xl' 'xh' 'yl' 'yh')

replace restart {
	ld	a, %1
	srl	a
	ld	%1, a
} by {
	srl	%1
	; peephole 10 shifted in %1 instead of a.
} if notUsed('a'), notSame(%1 'xl' 'xh' 'yl' 'yh')

replace restart {
	ld	a, %1
	tst	a
} by {
	tst	%1
	; peephole 11 tested in %1 instead of a.
} if notUsed('a'), notSame(%1 'xl' 'xh' 'yl' 'yh')

replace restart {
	call	%1
	ret
} by {
	jp	%1
	; peephole j1 replaced call at end of function by jump (tail call optimization).
}

replace restart {
	jp	%5
} by {
	jp	%6
	; peephole j2 jumped to %6 directly instead of via %5.
} if labelIsUncondJump(), notSame(%5 %6), labelRefCountChange(%5 -1), labelRefCountChange(%6 +1)

// Ensure jump-to-jump optimiation of absolute jumps above is done before other jump-related optimizations.
barrier

replace restart {
	ld	a, %1
	srl	a
	btjt	%1, #0, %2
} by {
	ld	a, %1
	srl	a
	; peephole j3 jumped by carry bit instead of testing bit explicitly.
	jrc %2
}

replace restart {
	ld	a, %1
	srl	a
	btjf	%1, #0, %2
} by {
	ld	a, %1
	srl	a
	; peephole j4 jumped by carry bit instead of testing bit explicitly.
	jrnc %2
}

replace restart {
	jp	%5
} by {
	jra	%5
	; peephole j5 changed absolute to relative unconditional jump.
} if labelInRange(%5)

replace restart {
	jrc	%1
	jra	%5
%1:
} by {
	jrnc	%5
	; peephole j6 removed jra by using inverse jump logic
%1:
} if labelRefCountChange(%1 -1)

replace restart {
	jreq	%1
	jra	%5
%1:
} by {
	jrne	%5
	; peephole j7 removed jra by using inverse jump logic
%1:
} if labelRefCountChange(%1 -1)

replace restart {
	jrmi	%1
	jra	%5
%1:
} by {
	jrpl	%5
	; peephole j8 removed jra by using inverse jump logic
%1:
} if labelRefCountChange(%1 -1)

replace restart {
	jrnc	%1
	jra	%5
%1:
} by {
	jrc	%5
	; peephole j9 removed jra by using inverse jump logic
%1:
} if labelRefCountChange(%1 -1)

replace restart {
	jrne	%1
	jra	%5
%1:
} by {
	jreq	%5
	; peephole j10 removed jra by using inverse jump logic
%1:
} if labelRefCountChange(%1 -1)

replace restart {
	jrpl	%1
	jra	%5
%1:
} by {
	jrmi	%5
	; peephole j11 removed jra by using inverse jump logic
%1:
} if labelRefCountChange(%1 -1)

replace restart {
	jrsge	%1
	jra	%5
%1:
} by {
	jrslt	%5
	; peephole j12 removed jra by using inverse jump logic
%1:
} if labelRefCountChange(%1 -1)

replace restart {
	jrsgt	%1
	jra	%5
%1:
} by {
	jrsle	%5
	; peephole j13 removed jra by using inverse jump logic
%1:
} if labelRefCountChange(%1 -1)

replace restart {
	jrsle	%1
	jra	%5
%1:
} by {
	jrsgt	%5
	; peephole j14 removed jra by using inverse jump logic
%1:
} if labelRefCountChange(%1 -1)

replace restart {
	jrslt	%1
	jra	%5
%1:
} by {
	jrsge	%5
	; peephole j15 removed jra by using inverse jump logic
%1:
} if labelRefCountChange(%1 -1)

replace restart {
	jrugt	%1
	jra	%5
%1:
} by {
	jrule	%5
	; peephole j16 removed jra by using inverse jump logic
%1:
} if labelRefCountChange(%1 -1)

replace restart {
	jrule	%1
	jra	%5
%1:
} by {
	jrugt	%5
	; peephole j17 removed jp by using inverse jump logic
%1:
} if labelRefCountChange(%1 -1)

replace restart {
	jrc	%5
} by {
	jrc	%6
	; peephole j18 jumped to %6 directly instead of via %5.
} if labelIsUncondJump(), notSame(%5 %6), labelInRange(%6), labelRefCountChange(%5 -1), labelRefCountChange(%6 +1)

replace restart {
	jreq	%5
} by {
	jreq	%6
	; peephole j19 jumped to %6 directly instead of via %5.
} if labelIsUncondJump(), notSame(%5 %6), labelInRange(%6), labelRefCountChange(%5 -1), labelRefCountChange(%6 +1)

replace restart {
	jrmi	%5
} by {
	jrmi	%6
	; peephole j20 jumped to %6 directly instead of via %5.
} if labelIsUncondJump(), notSame(%5 %6), labelInRange(%6), labelRefCountChange(%5 -1), labelRefCountChange(%6 +1)

replace restart {
	jrnc	%5
} by {
	jrnc	%6
	; peephole j21 jumped to %6 directly instead of via %5.
} if labelIsUncondJump(), notSame(%5 %6), labelInRange(%6), labelRefCountChange(%5 -1), labelRefCountChange(%6 +1)

replace restart {
	jrne	%5
} by {
	jrne	%6
	; peephole j22 jumped to %6 directly instead of via %5.
} if labelIsUncondJump(), notSame(%5 %6), labelInRange(%6), labelRefCountChange(%5 -1), labelRefCountChange(%6 +1)

replace restart {
	jrpl	%5
} by {
	jrpl	%6
	; peephole j23 jumped to %6 directly instead of via %5.
} if labelIsUncondJump(), notSame(%5 %6), labelInRange(%6), labelRefCountChange(%5 -1), labelRefCountChange(%6 +1)

replace restart {
	jrge	%5
} by {
	jrge	%6
	; peephole j24 jumped to %6 directly instead of via %5.
} if labelIsUncondJump(), notSame(%5 %6), labelInRange(%6), labelRefCountChange(%5 -1), labelRefCountChange(%6 +1)

replace restart {
	jrgt	%5
} by {
	jrgt	%6
	; peephole j25 jumped to %6 directly instead of via %5.
} if labelIsUncondJump(), notSame(%5 %6), labelInRange(%6), labelRefCountChange(%5 -1), labelRefCountChange(%6 +1)

replace restart {
	jrle	%5
} by {
	jrle	%6
	; peephole j26 jumped to %6 directly instead of via %5.
} if labelIsUncondJump(), notSame(%5 %6), labelInRange(%6), labelRefCountChange(%5 -1), labelRefCountChange(%6 +1)

replace restart {
	jrlt	%5
} by {
	jrlt	%6
	; peephole j27 jumped to %6 directly instead of via %5.
} if labelIsUncondJump(), notSame(%5 %6), labelInRange(%6), labelRefCountChange(%5 -1), labelRefCountChange(%6 +1)

replace restart {
	jrugt	%5
} by {
	jrugt	%6
	; peephole j28 jumped to %6 directly instead of via %5.
} if labelIsUncondJump(), notSame(%5 %6), labelInRange(%6), labelRefCountChange(%5 -1), labelRefCountChange(%6 +1)

replace restart {
	jrule	%5
} by {
	jrule	%6
	; peephole j29 jumped to %6 directly instead of via %5.
} if labelIsUncondJump(), notSame(%5 %6), labelInRange(%6), labelRefCountChange(%5 -1), labelRefCountChange(%6 +1)

// Should be one of the last ones. Opens the code to further peephole optimization.
replace restart {
%1:
} by {
	; peephole j18 removed unused label %1.
} if labelRefCount(%1 0)

